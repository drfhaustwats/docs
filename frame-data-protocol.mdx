---
title: "Frame Data Protocol"
description: "Deep dive into the 30MHz ParlIO→SPI frame protocol, 4-channel data formats, and NeoPixelBus LED control"
---

# Frame Data Protocol

The Frame Data Protocol is the high-speed communication backbone of the Watts v3 dual-MCU system, enabling synchronized LED control across ESP32-C5 and ESP32 WROOM processors. This protocol achieves sub-millisecond coordination of all 4 LED channels while maintaining data integrity through CRC validation.

## Protocol Overview

The frame protocol operates in three distinct phases:

```
Phase 1: Preparation    Phase 2: Data Transfer    Phase 3: Acknowledgment
ESP32-C5 → WROOM        ESP32-C5 → WROOM          WROOM → ESP32-C5
  AT+LED_PREP            30MHz ParlIO Stream         +LED_DONE URC
  (UART 921.6kbaud)      (All 4 channels data)      (Status report)
     ~1ms                     ~800µs                    ~10µs
```

**Channel Distribution:**
- **All 4 Channels (0-3)**: Transmitted to WROOM via ParlIO for RMT output
- **WLED Rendering**: C5 renders full 4-channel frame in WLED effects engine
- **NeoPixelBus**: Both C5 and WROOM use NeoPixelBus library for RMT-based LED control

## Frame Structure

### Frame Header (12 bytes)

```cpp
typedef struct __attribute__((packed)) {
    uint16_t magic;        // 0x4C45 ("LE" - Little Endian marker)
    uint16_t ch0_pixels;   // Channel 0 pixel count (0-1000)
    uint16_t ch1_pixels;   // Channel 1 pixel count (0-1000)
    uint16_t ch2_pixels;   // Channel 2 pixel count (0-1000)
    uint16_t ch3_pixels;   // Channel 3 pixel count (0-1000)
    uint16_t crc16;        // CRC16-CCITT of payload data
} led_frame_header_t;

static_assert(sizeof(led_frame_header_t) == 12, "header must be 12 bytes");
```

**Header Field Details:**
- **Magic Number**: `0x4C45` provides frame synchronization and endianness validation
- **Pixel Counts**: 16-bit values for all 4 channels (0-1000 pixels each)
- **CRC16**: CCITT-FALSE polynomial (`0x1021`) with `0xFFFF` initialization over payload only

### Frame Layout

```
Byte Position    Content                    Size
─────────────────────────────────────────────────
0-1             Magic (0x4C45)             2 bytes
2-3             Channel 0 pixel count      2 bytes
4-5             Channel 1 pixel count      2 bytes
6-7             Channel 2 pixel count      2 bytes
8-9             Channel 3 pixel count      2 bytes
10-11           CRC16 checksum             2 bytes
12-X            Channel 0 pixel data       ch0_pixels × 4
X+1-Y           Channel 1 pixel data       ch1_pixels × 4
Y+1-Z           Channel 2 pixel data       ch2_pixels × 4
Z+1-W           Channel 3 pixel data       ch3_pixels × 4

Maximum frame size: 12 + (1000 × 4 × 4) = 16,012 bytes
```

### Pixel Data Format

Each pixel uses 4 bytes in GRBW order (compatible with WS2812/SK6812):

```cpp
struct pixel_data {
    uint8_t green;      // Green component (0-255)
    uint8_t red;        // Red component (0-255)
    uint8_t blue;       // Blue component (0-255)
    uint8_t white;      // White component (0-255, unused for WS2812)
};
```

This format matches the native WS2812 bit order, eliminating the need for color reordering during NeoPixelBus RMT transmission.

## 30MHz ParlIO → SPI Data Transfer

### ParlIO TX Configuration (ESP32-C5)

The ESP32-C5 uses ParlIO (Parallel I/O) in serial mode for high-speed data transmission:

```cpp
parlio_tx_unit_config_t config = {
    .clk_src = PARLIO_CLK_SRC_DEFAULT,       // 30MHz APB clock source
    .output_clk_freq_hz = 30000000,          // 30MHz output clock
    .sample_edge = PARLIO_SAMPLE_EDGE_POS,   // Positive edge sampling
    .bit_pack_order = PARLIO_BIT_PACK_ORDER_MSB, // MSB first
    .data_width = 1,                         // 1-bit serial transmission
    .idle_value = 0,                         // Idle low
    .trans_queue_depth = 4,                  // 4 pending transactions
    .max_transfer_size = 16012               // Maximum frame size (4 channels)
};
```

**GPIO Assignments (configurable via PINS structure):**
```cpp
// ParlIO pins are defined via C5_PARLIO_* macros or PINS structure
config.clk_out_gpio_num = C5_PARLIO_CLK_OUT_PIN;   // Clock to WROOM
config.valid_gpio_num = C5_PARLIO_VALID_PIN;       // Frame valid signal
// Data pin assigned via data_gpio array
```

### ParlIO Timing Characteristics

**Clock Generation:**
- **Source**: 30MHz APB clock (PLL-derived)
- **Output**: 30MHz square wave with ~50% duty cycle
- **Jitter**: &lt;1ns RMS (crystal stability dependent)
- **Edge Rate**: &lt;5ns rise/fall time

**Data Timing:**
- **Setup Time**: 6.25ns before clock rising edge
- **Hold Time**: 6.25ns after clock rising edge
- **Valid Signal**: Asserted during entire frame transmission
- **Idle Behavior**: Clock continues, data held low

### SPI Slave Configuration (ESP32 WROOM)

The ESP32 WROOM receives the ParlIO stream via SPI slave interface:

```cpp
spi_bus_config_t buscfg = {
    .mosi_io_num = PINS.spis.mosi,       // Data from C5 (configurable)
    .sclk_io_num = PINS.spis.sck,        // Clock from C5 (configurable)
    .max_transfer_sz = SPI_LED_MAX_SEGMENT, // Maximum frame size
    .flags = SPICOMMON_BUSFLAG_SLAVE,    // Slave mode
    .intr_flags = ESP_INTR_FLAG_IRAM     // IRAM interrupt handler
};

spi_slave_interface_config_t slvcfg = {
    .mode = 0,                           // CPOL=0, CPHA=0
    .spics_io_num = PINS.spis.cs,        // Valid/CS from C5 (configurable)
    .queue_size = 7,                     // 7 transaction queue depth
    .flags = 0                           // MSB first reception (default)
};
```

**SPI Reception Strategy:**
- **Pre-allocated Buffers**: DMA-capable buffers (queue depth 7)
- **Circular Queuing**: Automatic re-queuing after processing
- **Zero-Copy Operation**: Direct DMA to processing buffers
- **Polling-Based**: Uses `spi_slave_get_trans_result()` with timeout

## CRC Validation

### CRC16-CCITT Implementation

The protocol uses CRC16-CCITT with optimized lookup table implementation:

```cpp
// High-performance lookup table (256 entries)
static const uint16_t crc16_table[256] = {
    0x0000,0x1021,0x2042,0x3063,0x4084,0x50A5,0x60C6,0x70E7,
    0x8108,0x9129,0xA14A,0xB16B,0xC18C,0xD1AD,0xE1CE,0xF1EF,
    // ... remaining 240 entries
};

static uint16_t crc16_ccitt_update(uint16_t crc, const uint8_t *data, size_t len) {
    while (len--) {
        uint8_t idx = (crc >> 8) ^ *data++;
        crc = (crc << 8) ^ crc16_table[idx];
    }
    return crc;
}
```

**CRC Calculation Scope:**
- **Included**: All pixel data (Channel 0 + 1 + 2 + 3)
- **Excluded**: Frame header (magic, pixel counts)
- **Performance**: ~15µs for 1000 pixels × 4 channels using lookup table

### Error Detection & Recovery

**Validation Process:**
1. **Frame Reception**: ESP32 WROOM receives complete frame via SPI
2. **Header Check**: Validate magic number and pixel counts
3. **CRC Verification**: Recompute CRC over payload data
4. **Comparison**: Compare computed CRC with header value

**Error Response Protocol:**
```cpp
// Success path
if (computed_crc == header_crc) {
    process_frame_data();
    send_at_response("+LED_DONE");
}
// Error path
else {
    log_crc_error();
    send_at_response("+LED_ERROR:CRC_MISMATCH");
}
```

## NeoPixelBus LED Control

Both the ESP32-C5 and ESP32 WROOM use the **NeoPixelBus library** for RMT-based LED strip control, not custom RMT implementations.

### ESP32-C5 NeoPixelBus Configuration

**Library Integration:**
```cpp
// NeoPixelBus manages RMT channels internally
#include <NeoPixelBus.h>

// WLED creates NeoPixelBus instances for configured channels
// NeoPixelBus handles all RMT configuration, timing, and DMA automatically
```

**Key Features:**
- **Automatic RMT Setup**: NeoPixelBus configures RMT channels at 40MHz
- **WS2812/SK6812 Support**: Built-in timing templates for common protocols
- **DMA Management**: Automatic DMA buffer allocation and management
- **Multi-Channel**: Supports multiple independent RMT channels

### ESP32 WROOM NeoPixelBus Configuration

**Library Integration:**
```cpp
// WROOM firmware uses type-erased NeoPixelBus strip management
// Strips allocated dynamically based on AT+LED_PREP parameters

// Custom NeoPixelBus driver for ESP32 WROOM:
// - NeoEsp32RmtNWs2812xMethod (RGB, 3 bytes/pixel)
// - NeoEsp32RmtNSk6812Method (RGBW, 4 bytes/pixel)
```

**Key Features:**
- **40MHz RMT Clock**: NeoPixelBus configures ESP32 RMT at 40MHz for precise timing
- **Type-Erased Strips**: Memory-efficient management of 4 channels with different formats
- **Dynamic Allocation**: Strips created/destroyed based on configuration changes
- **Efficient Memory**: Only allocates buffers for active channels

### NeoPixelBus Timing (WS2812)

NeoPixelBus handles all WS2812/SK6812 timing internally:

**40MHz RMT Configuration (both C5 and WROOM):**
- **T0H**: 400ns (16 cycles × 25ns)
- **T0L**: 850ns (34 cycles × 25ns)
- **T1H**: 850ns (34 cycles × 25ns)
- **T1L**: 450ns (18 cycles × 25ns)
- **Reset**: 280µs minimum (handled by NeoPixelBus)

**Timing Accuracy:**
- **Resolution**: ±25ns (40MHz clock period)
- **WS2812 Tolerance**: ±150ns typical
- **Margin**: Well within specification

## Synchronization Timing

### End-to-End Latency Analysis

**Complete Frame Cycle:**
```
Event                           Timing      Cumulative
─────────────────────────────────────────────────────
AT+LED_PREP command            ~100µs       100µs
WROOM SPI slave preparation    ~50µs        150µs
ParlIO frame transmission      ~800µs       950µs (4 channels)
WROOM CRC validation           ~15µs        965µs
WROOM NeoPixelBus setup        ~20µs        985µs
NeoPixelBus RMT start          ~10µs        995µs
+LED_DONE response             ~30µs        1025µs

Total coordination latency: ~1ms typical
```

**Frame Rate Capability:**
- **Maximum Theoretical**: 1000 FPS (1ms cycle time)
- **Practical Limit**: 120 FPS (accounting for WLED processing)
- **Recommended**: 60 FPS for optimal performance/power balance

### Clock Domain Crossing

**ParlIO to SPI Conversion:**
The ParlIO output is electrically compatible with SPI input, but requires careful timing:

```
ParlIO (C5)                 SPI Slave (WROOM)
───────────────             ──────────────────
CLK_OUT (30MHz)         →   SCLK (30MHz)
DATA0 (Serial)          →   MOSI (Serial)
VALID (Frame active)    →   CS (Active when frame valid)
```

**Critical Timing Requirements:**
- **Clock Skew**: &lt;2ns between CLK and DATA signals
- **Setup/Hold**: Meet SPI slave timing specifications
- **CS Assertion**: Must precede data by &gt;50ns

## Memory Architecture

### Buffer Allocation Strategy

```cpp
// ESP32-C5 Memory Usage (WLED + ParlIO)
WLED pixel buffers:     16KB   (4 channels × 1000 pixels × 4 bytes)
ParlIO frame buffer:    16KB   (DMA-capable, cache-aligned)
NeoPixelBus RMT:        Auto   (Managed by library)
AT command buffers:     2KB    (UART RX/TX queues)
Total C5 LED memory:   ~34KB

// ESP32 WROOM Memory Usage
SPI RX buffers:        128KB   (8 × 16KB circular buffer)
NeoPixelBus RMT:       Auto    (Managed by library, per-channel)
Frame processing:      16KB    (working copy)
AT response buffers:   1KB     (UART TX queue)
Total WROOM LED memory: ~145KB
```

**DMA Requirements:**
- **C5**: ParlIO requires DMA-capable buffers (MALLOC_CAP_DMA)
- **WROOM**: SPI slave uses automatic DMA with pre-allocated descriptors
- **NeoPixelBus**: Library handles RMT DMA buffer allocation internally
- **Cache Coherency**: ESP-IDF handles cache invalidation automatically
- **Alignment**: 64-byte alignment recommended for optimal DMA performance

## Performance Optimization

### Throughput Calculations

**ParlIO Bandwidth:**
```
Theoretical: 30 MHz × 1 bit = 30 Mbps = 3.75 MB/s
Effective:   ~90% efficiency = 3.38 MB/s (protocol overhead)
Frame size:  16012 bytes maximum (4 channels × 1000 pixels)
Frame time:  16012 ÷ 3,380,000 = 4.74ms maximum
Typical:     800 pixels/ch = 12812 bytes = 3.79ms
```

**System Bottlenecks:**
1. **AT Command Latency**: ~100µs (UART communication at 921.6 kbaud)
2. **WLED Rendering**: Variable (effect complexity dependent)
3. **Frame Validation**: ~15µs (CRC calculation)
4. **NeoPixelBus Setup**: ~20µs (library initialization)

### CPU Utilization

**ESP32-C5 Load (60 FPS, 1000 pixels/channel):**
- **WLED Effects**: 15-30% (effect dependent)
- **Frame Creation**: 3% (memory copy + CRC)
- **ParlIO Management**: &lt;1% (DMA-based)
- **AT Commands**: &lt;1% (queued processing)
- **NeoPixelBus**: &lt;2% (library overhead)
- **Total**: 19-36% typical

**ESP32 WROOM Load (60 FPS, 1000 pixels/channel):**
- **SPI Reception**: &lt;1% (DMA-based)
- **Frame Processing**: 5% (validation + splitting)
- **NeoPixelBus**: 8% (library + RMT management)
- **AT Processing**: &lt;1% (simple commands)
- **BLE Stack**: 5-10% (connection dependent)
- **Total**: 14-24% typical

## Error Handling & Recovery

### Communication Error Types

**Frame-Level Errors:**
- **Magic Mismatch**: Invalid frame header, frame discarded
- **CRC Failure**: Data corruption detected, retry requested
- **Size Overflow**: Frame exceeds buffer capacity, truncated
- **Timeout**: Frame reception incomplete, partial frame discarded

**System-Level Errors:**
- **WROOM Unresponsive**: AT command timeout, fallback to local mode
- **SPI Hardware Fault**: Bus reset and reinitialization
- **NeoPixelBus Fault**: Library error, channel reset and reconfiguration
- **Memory Exhaustion**: Buffer allocation failure, reduced frame size

### Recovery Mechanisms

**Automatic Recovery:**
```cpp
// Error counter and recovery logic
typedef struct {
    uint32_t crc_errors;           // CRC validation failures
    uint32_t timeout_errors;       // AT command timeouts
    uint32_t hardware_errors;      // SPI/NeoPixelBus faults
    uint32_t consecutive_errors;   // Consecutive error count
    bool fallback_mode;            // Emergency fallback active
} error_counters_t;

void handle_communication_error(error_type_t error) {
    counters.consecutive_errors++;

    if (counters.consecutive_errors > MAX_CONSECUTIVE_ERRORS) {
        ESP_LOGW(TAG, "Too many errors, enabling fallback mode");
        counters.fallback_mode = true;
        disable_wroom_communication();
    }

    // Attempt recovery every 10th error
    if (counters.consecutive_errors % 10 == 0) {
        attempt_wroom_recovery();
    }
}
```

**Fallback Operation:**
When ESP32 WROOM communication fails, the system can operate in fallback mode:
- **All Channels**: C5 can drive local channels via NeoPixelBus if configured
- **WROOM Channels**: Disabled until communication restored
- **Performance**: Depends on local channel configuration
- **Recovery**: Automatic retry every 30 seconds

This comprehensive frame protocol ensures reliable, high-performance LED control across the distributed dual-MCU architecture while leveraging the proven NeoPixelBus library for WS2812/SK6812 LED strip compatibility.

## Source Code References

The frame protocol implementation spans both firmware projects:

| Component | File | Description |
|-----------|------|-------------|
| **Frame Header (C5)** | `NeoEsp32ParlC5SharedManager.h` | `led_frame_header_t` struct, `LED_FRAME_MAGIC`, CRC16 table |
| **Frame Header (WROOM)** | `spi_led_controller.h` | `led_frame_header_t` struct, `LED_MAX_PIXELS_PER_CHANNEL` |
| **ParlIO TX Config** | `NeoEsp32ParlC5SharedManager.h` | `C5_PARLIO_BITRATE_HZ`, ParlIO unit initialization |
| **SPI Slave Config** | `spi_led_controller.cpp` | `led_controller_init()` function |
| **CRC16 Implementation** | `NeoEsp32ParlC5SharedManager.h` | `crc16_ccitt_update()` function, lookup table |
| **Pin Configuration** | `pins/pins.c` | Board-specific GPIO assignments via `PINS` structure |

**Key Constants:**
- `LED_FRAME_MAGIC = 0x4C45` - Frame synchronization marker ("LE")
- `C5_PARLIO_BITRATE_HZ = 30000000` - 30MHz ParlIO clock
- `LED_MAX_PIXELS_PER_CHANNEL = 1000` (C5) / `1200` (WROOM) - Per-channel pixel limits
- `QUEUE_SIZE = 7` - SPI slave transaction queue depth
