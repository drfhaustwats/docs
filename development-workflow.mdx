---
title: "Development Workflow"
description: "Complete guide to setting up build environments, debugging dual-MCU systems, OTA procedures, and testing strategies for the Watts v3 controller"
---

# Development Workflow

This chapter covers the complete development workflow for the Watts v3 dual-MCU lighting system, from initial setup through deployment and maintenance.

## Build Environment Setup

### Prerequisites

**Required Software:**
- **ESP-IDF v5.1+** - ESP32 development framework
- **Arduino IDE 2.0+** or **PlatformIO** - For Arduino as Component development
- **Git** - Version control
- **Python 3.8+** - ESP-IDF dependency
- **CMake 3.16+** - Build system
- **Ninja** - Build tool (recommended)

**Hardware Requirements:**
- ESP32-C5 development board with USB-C connector
- ESP32-H2 development board with USB-C connector  
- Logic analyzer (optional, for protocol debugging)
- Oscilloscope (optional, for signal timing analysis)

### ESP32-C5 Arduino Environment

**Directory Structure:**
```
watts-v3-controller/
‚îú‚îÄ‚îÄ esp32-c5-main/
‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ esp32-c5-main.ino
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NeoPixelBusH2.h
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NeoPixelBusH2.cpp
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ATHost.h
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ arduino/         # Arduino as Component
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
‚îÇ   ‚îî‚îÄ‚îÄ sdkconfig
‚îî‚îÄ‚îÄ esp32-h2-at/
    ‚îú‚îÄ‚îÄ main/
    ‚îú‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ CMakeLists.txt
```

**Arduino as Component Setup:**

1. **Clone Arduino ESP32 Core:**
```bash
cd esp32-c5-main/components
git clone --recursive https://github.com/espressif/arduino-esp32.git arduino
cd arduino
git checkout tags/2.0.14  # Use stable release
```

2. **Configure CMakeLists.txt:**
```cmake
# esp32-c5-main/CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

# Arduino as Component configuration
set(EXTRA_COMPONENT_DIRS "components/arduino")
set(ARDUINO_BOARD "ESP32C5_DEV")

include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(esp32-c5-main)
```

3. **Main Component Configuration:**
```cmake
# esp32-c5-main/main/CMakeLists.txt
idf_component_register(
    SRCS "esp32-c5-main.ino"
         "NeoPixelBusH2.cpp"
         "ATHost.cpp"
    INCLUDE_DIRS "."
    REQUIRES arduino
             esp_driver_uart
             esp_driver_rmt
             esp_driver_gpio
)
```

**Arduino as Component Configuration:**

Create `sdkconfig.defaults` for consistent ESP32-C5 builds:

```bash
# esp32-c5-main/sdkconfig.defaults
# Target configuration
CONFIG_IDF_TARGET="esp32c5"

# Arduino as Component configuration
CONFIG_ARDUINO_RUNNING_CORE=1
CONFIG_ARDUINO_LOOP_STACK_SIZE=8192
CONFIG_ARDUINO_EVENT_RUNNING_CORE=1
CONFIG_ARDUINO_EVENT_STACK_SIZE=4096
CONFIG_ARDUINO_UDP_RUNNING_CORE=1
CONFIG_ARDUINO_UDP_TASK_PRIORITY=3

# Enable Arduino features needed for NeoPixelBus
CONFIG_ARDUINO_ENABLE_WDT=y
CONFIG_ARDUINO_WDT_TIMEOUT=5000
CONFIG_ARDUINO_AUTOSTART_ARDUINO=y

# ESP32-C5 specific configurations
CONFIG_ESP_DEFAULT_CPU_FREQ_240=y
CONFIG_COMPILER_OPTIMIZATION_PERF=y

# UART configuration for AT communication
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_CONSOLE_UART_NUM=0

# GPIO and driver configuration
CONFIG_ESP_DRIVER_GPIO_ENABLE_DEBUG_LOG=n
CONFIG_ESP_DRIVER_RMT_ENABLE_DEBUG_LOG=n
CONFIG_ESP_DRIVER_UART_ENABLE_DEBUG_LOG=n

# Memory configuration
CONFIG_ESP_MAIN_TASK_STACK_SIZE=8192
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=4096

# ParlIO configuration for high-speed LED data
CONFIG_ESP_DRIVER_PARLIO_ENABLE_DEBUG_LOG=n

# Flash configuration
CONFIG_ESPTOOLPY_FLASHSIZE_4MB=y
CONFIG_PARTITION_TABLE_SINGLE_APP=y

# WiFi configuration (if needed for future features)
CONFIG_ESP32_WIFI_ENABLED=y
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=4
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=8
```

**Build Commands:**
```bash
# Set target and build (sdkconfig.defaults automatically applied)
cd esp32-c5-main
idf.py set-target esp32c5
idf.py build
idf.py flash monitor
```

### ESP32-H2 ESP-IDF Environment

**Project Structure:**
```
esp32-h2-at/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îú‚îÄ‚îÄ EspAt_firmware.c
‚îÇ   ‚îú‚îÄ‚îÄ cat.c               # Tiny-CAT parser
‚îÇ   ‚îú‚îÄ‚îÄ ble_at_handler.c    # BLE commands
‚îÇ   ‚îú‚îÄ‚îÄ gatt_svc.c          # GATT services
‚îÇ   ‚îú‚îÄ‚îÄ gap.c               # GAP management
‚îÇ   ‚îú‚îÄ‚îÄ at_led_commands.c   # LED commands
‚îÇ   ‚îú‚îÄ‚îÄ spi_led_controller.c # SPI slave
‚îÇ   ‚îú‚îÄ‚îÄ led_strip_encoder.c # RMT encoder
‚îÇ   ‚îî‚îÄ‚îÄ ota.c               # OTA handler
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ tiny_cat/           # AT parser library
‚îú‚îÄ‚îÄ partitions.csv
‚îú‚îÄ‚îÄ sdkconfig.defaults
‚îî‚îÄ‚îÄ CMakeLists.txt
```

**ESP-IDF Configuration:**

Create `sdkconfig.defaults` for automated configuration:

```bash
# esp32-h2-at/sdkconfig.defaults
# Target configuration
CONFIG_IDF_TARGET="esp32h2"

# Bluetooth configuration
CONFIG_BT_ENABLED=y
CONFIG_BT_NIMBLE_ENABLED=y
CONFIG_BT_NIMBLE_ROLE_PERIPHERAL=y
CONFIG_BT_NIMBLE_ROLE_CENTRAL=n
CONFIG_BT_NIMBLE_MAX_CONNECTIONS=1
CONFIG_BT_NIMBLE_MAX_CCCDS=8
CONFIG_BT_NIMBLE_HOST_TASK_STACK_SIZE=4096

# FreeRTOS configuration
CONFIG_FREERTOS_HZ=1000
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=4096

# Flash and partition configuration
CONFIG_ESPTOOLPY_FLASHSIZE_4MB=y
CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"

# UART configuration for high-speed AT communication
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_CONSOLE_UART_NUM=0

# Memory optimization
CONFIG_ESP_DEFAULT_CPU_FREQ_96=y
CONFIG_COMPILER_OPTIMIZATION_SIZE=y

# Security features
CONFIG_SECURE_BOOT=n
CONFIG_SECURE_FLASH_ENC_ENABLED=n

# SPI configuration for LED controller
CONFIG_ESP_DRIVER_SPI_MASTER_ISR_IN_IRAM=y
CONFIG_ESP_DRIVER_SPI_SLAVE_ISR_IN_IRAM=y

# RMT configuration for LED output
CONFIG_ESP_DRIVER_RMT_ENABLE_DEBUG_LOG=n
```

**Build Commands:**
```bash
# Set target and build (sdkconfig.defaults automatically applied)
cd esp32-h2-at
idf.py set-target esp32h2
idf.py build
idf.py flash monitor
```

**Custom Partition Table:**
```csv
# esp32-h2-at/partitions.csv
# Name,     Type, SubType, Offset,  Size, Flags
nvs,        data, nvs,     0x9000,  0x6000,
phy_init,   data, phy,     0xf000,  0x1000,
factory,    app,  factory, 0x10000, 0x180000,
ota_0,      app,  ota_0,   0x190000,0x180000,
ota_1,      app,  ota_1,   0x310000,0x180000,
ota_data,   data, ota,     0x490000,0x2000,
```

## Cross-Platform Build Scripts

### Unified Build System

**File**: `build-all.py`
```python
#!/usr/bin/env python3
"""
Unified build script for Watts v3 dual-MCU system
Supports both Windows and Linux development environments
"""

import os
import sys
import subprocess
import argparse
from pathlib import Path

class DualMCUBuilder:
    def __init__(self, project_root):
        self.project_root = Path(project_root)
        self.c5_path = self.project_root / "esp32-c5-main"
        self.h2_path = self.project_root / "esp32-h2-at"
        
    def build_c5(self, clean=False):
        """Build ESP32-C5 Arduino firmware"""
        print("üî® Building ESP32-C5 firmware...")
        os.chdir(self.c5_path)
        
        if clean:
            subprocess.run(["idf.py", "fullclean"], check=True)
            
        # Configure and build
        subprocess.run(["idf.py", "set-target", "esp32c5"], check=True)
        subprocess.run(["idf.py", "build"], check=True)
        
        print("‚úÖ ESP32-C5 build complete")
        
    def build_h2(self, clean=False):
        """Build ESP32-H2 AT firmware"""
        print("üî® Building ESP32-H2 firmware...")
        os.chdir(self.h2_path)
        
        if clean:
            subprocess.run(["idf.py", "fullclean"], check=True)
            
        # Configure and build
        subprocess.run(["idf.py", "set-target", "esp32h2"], check=True)
        subprocess.run(["idf.py", "build"], check=True)
        
        print("‚úÖ ESP32-H2 build complete")
        
    def flash_c5(self, monitor=False):
        """Flash ESP32-C5 firmware"""
        print("üì± Flashing ESP32-C5...")
        os.chdir(self.c5_path)
        
        cmd = ["idf.py", "flash"]
        if monitor:
            cmd.append("monitor")
            
        subprocess.run(cmd, check=True)
        
    def flash_h2(self, monitor=False):
        """Flash ESP32-H2 firmware"""
        print("üì± Flashing ESP32-H2...")
        os.chdir(self.h2_path)
        
        cmd = ["idf.py", "flash"]
        if monitor:
            cmd.append("monitor")
            
        subprocess.run(cmd, check=True)
        
    def run_tests(self):
        """Run automated test suite"""
        print("üß™ Running test suite...")
        
        # Unit tests for AT commands
        os.chdir(self.h2_path)
        subprocess.run(["python", "tests/test_at_commands.py"], check=True)
        
        # Integration tests
        subprocess.run(["python", "tests/test_dual_mcu_integration.py"], check=True)
        
        print("‚úÖ All tests passed")

def main():
    parser = argparse.ArgumentParser(description="Watts v3 build system")
    parser.add_argument("--clean", action="store_true", help="Clean before build")
    parser.add_argument("--c5-only", action="store_true", help="Build C5 only")
    parser.add_argument("--h2-only", action="store_true", help="Build H2 only")
    parser.add_argument("--flash", action="store_true", help="Flash after build")
    parser.add_argument("--monitor", action="store_true", help="Monitor after flash")
    parser.add_argument("--test", action="store_true", help="Run tests")
    
    args = parser.parse_args()
    
    builder = DualMCUBuilder(".")
    
    try:
        if args.c5_only:
            builder.build_c5(args.clean)
            if args.flash:
                builder.flash_c5(args.monitor)
        elif args.h2_only:
            builder.build_h2(args.clean)
            if args.flash:
                builder.flash_h2(args.monitor)
        else:
            # Build both
            builder.build_c5(args.clean)
            builder.build_h2(args.clean)
            
            if args.flash:
                print("üö® Flash both MCUs manually with --c5-only/--h2-only")
                
        if args.test:
            builder.run_tests()
            
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

**Usage Examples:**
```bash
# Build both MCUs
python build-all.py

# Clean build C5 and flash with monitor
python build-all.py --c5-only --clean --flash --monitor

# Build and test H2
python build-all.py --h2-only --test

# Complete workflow
python build-all.py --clean --test
```

## Debugging Dual-MCU Systems

### Serial Monitor Setup

**Multi-Terminal Debugging:**

**Terminal 1 - ESP32-C5:**
```bash
# Monitor C5 main controller
cd esp32-c5-main
idf.py monitor --port /dev/ttyUSB0
# Windows: idf.py monitor --port COM3
```

**Terminal 2 - ESP32-H2:**
```bash
# Monitor H2 AT controller
cd esp32-h2-at  
idf.py monitor --port /dev/ttyUSB1
# Windows: idf.py monitor --port COM4
```

**Terminal 3 - AT Communication:**
```bash
# Monitor AT command flow between MCUs
python tools/at_monitor.py --c5-port /dev/ttyUSB0 --h2-port /dev/ttyUSB1
```

### AT Command Flow Debugger

**File**: `tools/at_monitor.py`
```python
#!/usr/bin/env python3
"""
Real-time AT command flow monitor for dual-MCU debugging
"""

import serial
import threading
import time
import re
from datetime import datetime

class ATFlowMonitor:
    def __init__(self, c5_port, h2_port, baudrate=115200):
        self.c5_serial = serial.Serial(c5_port, baudrate, timeout=0.1)
        self.h2_serial = serial.Serial(h2_port, baudrate, timeout=0.1)
        self.running = False
        
    def start_monitoring(self):
        """Start monitoring both serial ports"""
        self.running = True
        
        # Start monitoring threads
        threading.Thread(target=self._monitor_c5, daemon=True).start()
        threading.Thread(target=self._monitor_h2, daemon=True).start()
        
        print("üîç AT Flow Monitor started")
        print("üì° C5 (Main) | üì± H2 (AT)")
        print("-" * 50)
        
        try:
            while self.running:
                time.sleep(0.1)
        except KeyboardInterrupt:
            self.stop_monitoring()
            
    def _monitor_c5(self):
        """Monitor C5 serial output"""
        buffer = ""
        while self.running:
            try:
                data = self.c5_serial.read(64).decode('utf-8', errors='ignore')
                if data:
                    buffer += data
                    lines = buffer.split('\n')
                    buffer = lines[-1]  # Keep incomplete line
                    
                    for line in lines[:-1]:
                        if line.strip():
                            self._process_c5_line(line.strip())
            except:
                pass
                
    def _monitor_h2(self):
        """Monitor H2 serial output"""
        buffer = ""
        while self.running:
            try:
                data = self.h2_serial.read(64).decode('utf-8', errors='ignore')
                if data:
                    buffer += data
                    lines = buffer.split('\n')
                    buffer = lines[-1]
                    
                    for line in lines[:-1]:
                        if line.strip():
                            self._process_h2_line(line.strip())
            except:
                pass
                
    def _process_c5_line(self, line):
        """Process C5 log line"""
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        
        # Detect AT commands being sent
        if "AT+" in line:
            print(f"üì° {timestamp} C5‚ÜíH2: {line}")
        elif "ATHost" in line or "NeoPixelBus" in line:
            print(f"üì° {timestamp} C5: {line}")
            
    def _process_h2_line(self, line):
        """Process H2 log line"""
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        
        # Detect AT responses and URCs
        if line.startswith('+') or line in ['OK', 'ERROR']:
            print(f"üì± {timestamp} H2‚ÜíC5: {line}")
        elif "cat_" in line or "BLE" in line or "LED" in line:
            print(f"üì± {timestamp} H2: {line}")
            
    def stop_monitoring(self):
        """Stop monitoring"""
        self.running = False
        self.c5_serial.close()
        self.h2_serial.close()
        print("\nüõë Monitoring stopped")

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--c5-port", required=True, help="C5 serial port")
    parser.add_argument("--h2-port", required=True, help="H2 serial port")
    args = parser.parse_args()
    
    monitor = ATFlowMonitor(args.c5_port, args.h2_port)
    monitor.start_monitoring()
```

### Logic Analyzer Configuration

**Recommended Channels:**
1. **UART TX (C5‚ÜíWROOM)** - AT commands
2. **UART RX (WROOM‚ÜíC5)** - AT responses
3. **SPI CLK** - 30MHz frame clock
4. **SPI MOSI** - Frame data
5. **SPI CS** - Frame valid signal
6. **LED CH0 Output** - RMT channel 0
7. **LED CH2 Output** - RMT channel 2
8. **LED CH3 Output** - RMT channel 3

**Trigger Configuration:**
```
# AT Command Analysis
Trigger: UART TX edge, decode: UART (921.6kbaud, 8N1)

# Frame Data Analysis  
Trigger: SPI CS falling edge, decode: SPI (30MHz, Mode 0)

# LED Output Timing
Trigger: LED output rising edge, timebase: 100ns/div
```

## OTA Update Procedures

### Over-UART Firmware Updates

**OTA Update Flow:**
```
C5 Controller                    H2 AT Firmware
‚îÇ                                ‚îÇ
‚îú‚îÄ 1. Send AT+OTAUPDATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ
‚îÇ                                ‚îú‚îÄ 2. Enter HOLD state
‚îÇ                                ‚îú‚îÄ 3. Wait for sync pattern
‚îú‚îÄ 4. Send sync: C0 FF FE AA 55 90‚îÇ
‚îÇ                                ‚îú‚îÄ 5. Begin OTA partition
‚îú‚îÄ 6. Stream firmware binary ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ
‚îÇ    (1KB chunks with CRC)       ‚îú‚îÄ 7. Validate and write
‚îÇ                                ‚îú‚îÄ 8. Set boot partition
‚îú‚îÄ 9. Receive "OK" response ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                ‚îú‚îÄ 10. Restart ESP32-H2
‚îî‚îÄ 11. Re-initialize AT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ
```

### OTA Client Implementation

**File**: `tools/ota_update.py`
```python
#!/usr/bin/env python3
"""
OTA firmware update tool for ESP32-H2 via UART
"""

import serial
import time
import struct
import binascii
from pathlib import Path

class H2OTAUpdater:
    def __init__(self, serial_port, baudrate=5000000):
        self.serial = serial.Serial(serial_port, baudrate, timeout=30)
        self.sync_pattern = b'\xC0\xFF\xFE\xAA\x55\x90'
        
    def update_firmware(self, firmware_path):
        """Update H2 firmware via OTA"""
        firmware = Path(firmware_path).read_bytes()
        
        print(f"üì¶ Firmware size: {len(firmware)} bytes")
        
        # 1. Send OTA command
        print("üöÄ Starting OTA update...")
        self.serial.write(b"AT+OTAUPDATE\r\n")
        
        # Wait for HOLD state confirmation
        response = self._read_response(timeout=5)
        if "HOLD" not in response:
            raise Exception(f"OTA start failed: {response}")
            
        # 2. Send sync pattern
        print("üîÑ Sending sync pattern...")
        time.sleep(0.1)
        self.serial.write(self.sync_pattern)
        
        # 3. Stream firmware in 1KB chunks
        chunk_size = 1024
        total_chunks = (len(firmware) + chunk_size - 1) // chunk_size
        
        for i in range(total_chunks):
            start = i * chunk_size
            end = min(start + chunk_size, len(firmware))
            chunk = firmware[start:end]
            
            # Send chunk with length prefix
            chunk_header = struct.pack('<H', len(chunk))
            self.serial.write(chunk_header + chunk)
            
            # Progress indicator
            progress = (i + 1) / total_chunks * 100
            print(f"üìä Progress: {progress:.1f}% ({i+1}/{total_chunks})", end='\r')
            
        print("\n‚úÖ Firmware transmission complete")
        
        # 4. Wait for completion
        print("‚è≥ Waiting for OTA completion...")
        response = self._read_response(timeout=60)
        
        if "OK" in response:
            print("üéâ OTA update successful!")
            print("‚ö° ESP32-H2 will restart automatically")
            return True
        else:
            print(f"‚ùå OTA update failed: {response}")
            return False
            
    def _read_response(self, timeout=10):
        """Read AT response with timeout"""
        start_time = time.time()
        response = ""
        
        while time.time() - start_time < timeout:
            if self.serial.in_waiting:
                data = self.serial.read(self.serial.in_waiting).decode('utf-8', errors='ignore')
                response += data
                
                if '\n' in response:
                    break
                    
            time.sleep(0.01)
            
        return response.strip()

# Usage example
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 3:
        print("Usage: python ota_update.py <port> <firmware.bin>")
        sys.exit(1)
        
    port = sys.argv[1]
    firmware = sys.argv[2]
    
    updater = H2OTAUpdater(port)
    success = updater.update_firmware(firmware)
    
    sys.exit(0 if success else 1)
```

**OTA Update Script:**
```bash
#!/bin/bash
# update_h2.sh - Complete H2 OTA update workflow

set -e

H2_PORT=${1:-/dev/ttyUSB1}
FIRMWARE_PATH="esp32-h2-at/build/EspAt_firmware.bin"

echo "üîß Building latest H2 firmware..."
cd esp32-h2-at
idf.py build

echo "üì° Starting OTA update on $H2_PORT..."
cd ..
python tools/ota_update.py "$H2_PORT" "$FIRMWARE_PATH"

echo "‚è≥ Waiting for H2 restart..."
sleep 5

echo "üîç Testing AT communication..."
python tools/test_at_basic.py "$H2_PORT"

echo "‚úÖ H2 OTA update complete!"
```

## Testing Strategies

### Automated Test Suite

**Test Categories:**

1. **Unit Tests** - Individual component testing
2. **Integration Tests** - MCU communication testing  
3. **Performance Tests** - Timing and throughput
4. **Stress Tests** - Extended operation and error recovery

### AT Command Testing

**File**: `tests/test_at_commands.py`
```python
#!/usr/bin/env python3
"""
Comprehensive AT command test suite
"""

import unittest
import serial
import time
import json

class ATCommandTests(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.serial = serial.Serial('/dev/ttyUSB1', 5000000, timeout=2)
        time.sleep(1)  # Allow H2 to initialize
        
    def test_basic_commands(self):
        """Test basic AT command functionality"""
        # Test AT ping
        self._send_command("AT")
        response = self._read_response()
        self.assertIn("OK", response)
        
    def test_ble_initialization(self):
        """Test BLE stack initialization"""
        # Initialize BLE server mode
        self._send_command("AT+BLEINIT=2")
        response = self._read_response(timeout=10)
        self.assertIn("OK", response)
        
        # Set device name
        self._send_command('AT+BLENAME="Watts-Test"')
        response = self._read_response()
        self.assertIn("OK", response)
        
    def test_led_commands(self):
        """Test LED controller commands"""
        # Prepare LED frame
        self._send_command("AT+LED_PREP=100,200")
        response = self._read_response()
        self.assertIn("OK", response)
        
        # Check statistics
        self._send_command("AT+LED_STATS")
        response = self._read_response()
        self.assertIn("+LED_STATS:SPI", response)
        
    def test_error_handling(self):
        """Test error conditions"""
        # Invalid command
        self._send_command("AT+INVALID")
        response = self._read_response()
        self.assertIn("ERROR", response)
        
        # Invalid parameter
        self._send_command("AT+LED_PREP=10000,20000")  # Too many pixels
        response = self._read_response()
        self.assertIn("ERROR", response)
        
    def _send_command(self, command):
        """Send AT command"""
        self.serial.write(f"{command}\r\n".encode())
        
    def _read_response(self, timeout=5):
        """Read AT response"""
        start_time = time.time()
        response = ""
        
        while time.time() - start_time < timeout:
            if self.serial.in_waiting:
                data = self.serial.read(self.serial.in_waiting).decode('utf-8', errors='ignore')
                response += data
                
                if 'OK\r\n' in response or 'ERROR\r\n' in response:
                    break
                    
            time.sleep(0.01)
            
        return response

if __name__ == "__main__":
    unittest.main()
```

### Performance Benchmarking

**File**: `tests/performance_test.py`
```python
#!/usr/bin/env python3
"""
Performance benchmarking for dual-MCU system
"""

import time
import statistics
import serial

class PerformanceTests:
    def __init__(self, h2_port):
        self.h2_serial = serial.Serial(h2_port, 5000000, timeout=1)
        
    def test_at_command_latency(self, iterations=100):
        """Measure AT command response latency"""
        latencies = []
        
        for i in range(iterations):
            start_time = time.time()
            self.h2_serial.write(b"AT\r\n")
            
            # Wait for OK response
            response = ""
            while True:
                data = self.h2_serial.read(10).decode('utf-8', errors='ignore')
                response += data
                if 'OK' in response:
                    break
                    
            end_time = time.time()
            latency_ms = (end_time - start_time) * 1000
            latencies.append(latency_ms)
            
            if i % 10 == 0:
                print(f"Progress: {i}/{iterations}")
                
        # Calculate statistics
        avg_latency = statistics.mean(latencies)
        min_latency = min(latencies)
        max_latency = max(latencies)
        p95_latency = sorted(latencies)[int(0.95 * len(latencies))]
        
        print(f"AT Command Latency Results ({iterations} samples):")
        print(f"  Average: {avg_latency:.2f}ms")
        print(f"  Minimum: {min_latency:.2f}ms")
        print(f"  Maximum: {max_latency:.2f}ms")
        print(f"  95th %ile: {p95_latency:.2f}ms")
        
        return {
            'avg': avg_latency,
            'min': min_latency, 
            'max': max_latency,
            'p95': p95_latency
        }
        
    def test_led_frame_throughput(self, frame_count=50):
        """Test LED frame processing throughput"""
        pixel_counts = [(100, 100), (500, 500), (1000, 1000)]
        
        for ch2_pixels, ch3_pixels in pixel_counts:
            print(f"Testing {ch2_pixels}+{ch3_pixels} pixels...")
            
            # Prepare LED controller
            cmd = f"AT+LED_PREP={ch2_pixels},{ch3_pixels}\r\n"
            self.h2_serial.write(cmd.encode())
            self._read_response()
            
            # Measure frame processing time
            start_time = time.time()
            
            for i in range(frame_count):
                # Simulate frame reception completion
                # (In real test, this would be triggered by SPI frame)
                time.sleep(0.001)  # 1ms per frame simulation
                
            end_time = time.time()
            
            total_time = end_time - start_time
            frames_per_second = frame_count / total_time
            pixels_per_second = (ch2_pixels + ch3_pixels) * frames_per_second
            
            print(f"  {frames_per_second:.1f} FPS")
            print(f"  {pixels_per_second/1000:.1f}K pixels/sec")
            
    def _read_response(self):
        """Read AT response"""
        response = ""
        while True:
            data = self.h2_serial.read(50).decode('utf-8', errors='ignore')
            response += data
            if 'OK' in response or 'ERROR' in response:
                break
        return response

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python performance_test.py <h2_port>")
        sys.exit(1)
        
    h2_port = sys.argv[1]
    tester = PerformanceTests(h2_port)
    
    print("üöÄ Starting performance tests...")
    tester.test_at_command_latency()
    print()
    tester.test_led_frame_throughput()
    print("‚úÖ Performance tests complete")
```

## Continuous Integration

### GitHub Actions Workflow

**File**: `.github/workflows/build.yml`
```yaml
name: Build Watts v3 Firmware

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-esp32c5:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: recursive
        
    - name: Setup ESP-IDF
      uses: espressif/esp-idf-ci-action@v1
      with:
        esp_idf_version: v5.1.2
        
    - name: Build ESP32-C5 firmware
      working-directory: esp32-c5-main
      run: |
        idf.py set-target esp32c5
        idf.py build
        
    - name: Upload C5 artifacts
      uses: actions/upload-artifact@v3
      with:
        name: esp32-c5-firmware
        path: esp32-c5-main/build/*.bin
        
  build-esp32h2:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: recursive
        
    - name: Setup ESP-IDF
      uses: espressif/esp-idf-ci-action@v1
      with:
        esp_idf_version: v5.1.2
        
    - name: Build ESP32-H2 firmware
      working-directory: esp32-h2-at
      run: |
        idf.py set-target esp32h2
        idf.py build
        
    - name: Upload H2 artifacts
      uses: actions/upload-artifact@v3
      with:
        name: esp32-h2-firmware
        path: esp32-h2-at/build/*.bin
        
  test:
    runs-on: ubuntu-latest
    needs: [build-esp32c5, build-esp32h2]
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        pip install pyserial
        
    - name: Run unit tests
      run: |
        python -m pytest tests/ -v
```

This comprehensive development workflow provides the foundation for efficient dual-MCU development, from initial setup through deployment and maintenance. The automated testing and CI/CD pipeline ensures code quality and system reliability throughout the development lifecycle.