---
title: "LED Control Commands"
description: "AT commands for LED frame coordination and control"
---

# LED Control AT Commands

LED control commands manage the high-speed coordination of LED frame data between the ESP32-C5 and ESP32-H2 MCUs.

## AT+LED_PREP

Prepares the ESP32-H2 to receive LED frame data via SPI slave interface.

**Parameters:**
- `ch2_pixels` (integer, required): Number of pixels for LED channel 2 (0-1000)
- `ch3_pixels` (integer, required): Number of pixels for LED channel 3 (0-1000)

### Request
```
AT+LED_PREP=<ch2_pixels>,<ch3_pixels>
```

### Response
```
OK      # H2 ready to receive frame data
ERROR   # Failed to prepare (invalid params or busy)
```

### Example
```bash
AT+LED_PREP=500,300
OK

# ESP32-H2 now ready to receive frame data for:
# - Channel 2: 500 pixels  
# - Channel 3: 300 pixels
```

### Implementation Details
- **Timeout**: 100ms (time-critical operation)
- **SPI Setup**: Configures SPI slave DMA for frame reception
- **Frame Format**: Expects 8-byte header + pixel data
- **Maximum Frame**: 8,008 bytes (1000 pixels × 4 bytes × 2 channels + header)

### Error Conditions
- Invalid pixel counts (negative or > 1000)
- SPI slave already busy with previous frame
- Insufficient memory for frame buffer allocation

---

## AT+LED_STATS

Returns LED controller statistics and current state.

### Request
```
AT+LED_STATS
```

### Response
```
+LED_STATS:SPI,<state>,<frames_ok>,<frames_error>,<crc_errors>
```

**Response Fields:**
- `state` (string): Current LED controller state: IDLE, PREP, RECEIVING, PROCESSING
- `frames_ok` (integer): Total successfully processed frames since boot
- `frames_error` (integer): Total frames that failed processing
- `crc_errors` (integer): Total frames with CRC checksum errors

### Example
```bash
AT+LED_STATS
+LED_STATS:SPI,IDLE,1247,3,0
OK

# Status: IDLE state, 1247 good frames, 3 errors, 0 CRC failures
```

### State Descriptions

| State | Description |
|-------|-------------|
| `IDLE` | Not processing, ready for new frame |
| `PREP` | Prepared and waiting for frame data |
| `RECEIVING` | Currently receiving frame via SPI |
| `PROCESSING` | Processing frame data to RMT channels |

---

## AT+LED_RESET

Resets the LED controller to idle state, clearing any ongoing operations.

### Request
```
AT+LED_RESET
```

### Response
```
OK      # LED controller reset successfully
ERROR   # Reset failed (should not occur)
```

### Example
```bash
AT+LED_RESET
OK

# LED controller now in IDLE state
# Any ongoing frame operations cancelled
```

### Use Cases
- Recovery from frame timeout or error conditions
- Clearing stuck SPI operations
- System initialization/cleanup
- Emergency stop of LED operations

### Implementation Details
- **Effect**: Stops SPI slave, clears frame buffers, resets RMT channels
- **Timing**: Immediate operation, no frame synchronization required
- **Safety**: Safe to call at any time, even during frame processing

---

## Unsolicited Result Codes (URCs)

### +LED_DONE

Sent automatically when the ESP32-H2 completes processing a LED frame.

```
+LED_DONE:<frame_id>
```

**Response Fields:**
- `frame_id` (integer): Frame sequence number for synchronization with ESP32-C5

#### Example
```bash
# After AT+LED_PREP and successful frame transmission:
+LED_DONE:123

# Frame 123 has been processed and output to RMT channels 2&3
```

#### Timing
- **Latency**: <5µs from SPI reception complete to RMT output start
- **Synchronization**: Enables frame-locked rendering across both MCUs
- **Reliability**: Only sent after successful CRC verification and RMT setup

---

## Integration with NeoPixelBus

The LED commands integrate automatically with the NeoPixelBus framework on ESP32-C5:

```cpp
// NeoEsp32ParlC5SharedManager.h integration
void _sendH2PrepCommand() {
    uint16_t ch2_pixels = _channels[2].registered ? _channels[2].pixelCount : 0;
    uint16_t ch3_pixels = _channels[3].registered ? _channels[3].pixelCount : 0;
    
    // Only send if pixel counts changed
    if (ch2_pixels == _lastCh2 && ch3_pixels == _lastCh3) return;
    _lastCh2 = ch2_pixels;
    _lastCh3 = ch3_pixels;

    char cmd[64];
    snprintf(cmd, sizeof(cmd), "AT+LED_PREP=%d,%d", ch2_pixels, ch3_pixels);

    bool success = ATHost_sendATWaitOK(cmd, 1000); // 1000ms timeout
    if (!success) {
        ESP_LOGW(TAG, "Failed to send LED_PREP to H2");
        _handleH2CommunicationError();
    } else {
        ESP_LOGD(TAG, "Sent LED_PREP to H2: ch2=%d, ch3=%d", ch2_pixels, ch3_pixels);
    }
}
```

### Automatic Frame Coordination

1. **WLED Render**: Calculates full 4-channel frame
2. **AT+LED_PREP**: Notifies H2 of channels 2&3 pixel counts
3. **ParlIO Stream**: 80MHz data transmission to H2 SPI slave
4. **+LED_DONE**: H2 confirms frame processing complete
5. **Next Frame**: Process repeats for next frame

This coordination ensures perfect synchronization between local (C5) and remote (H2) LED outputs.