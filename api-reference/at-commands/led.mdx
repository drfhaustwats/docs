---
title: "LED Control Commands"
description: "AT commands for LED frame coordination and control"
---

# LED Control AT Commands

LED control commands manage the high-speed coordination of LED frame data between the ESP32-C5 and ESP32 WROOM MCUs.

## AT+LED_PREP

Prepares the ESP32 WROOM to receive LED frame data via SPI slave interface for all 4 LED channels.

**Parameters:**
- `px0` (integer, required): Number of pixels for LED channel 0 (0-1200, 0 = disabled)
- `px1` (integer, required): Number of pixels for LED channel 1 (0-1200, 0 = disabled)
- `px2` (integer, required): Number of pixels for LED channel 2 (0-1200, 0 = disabled)
- `px3` (integer, required): Number of pixels for LED channel 3 (0-1200, 0 = disabled)
- `fmt0` (integer, required): Color format for channel 0 (3=RGB, 4=RGBW)
- `fmt1` (integer, required): Color format for channel 1 (3=RGB, 4=RGBW)
- `fmt2` (integer, required): Color format for channel 2 (3=RGB, 4=RGBW)
- `fmt3` (integer, required): Color format for channel 3 (3=RGB, 4=RGBW)

### Request
```
AT+LED_PREP=<px0>,<px1>,<px2>,<px3>,<fmt0>,<fmt1>,<fmt2>,<fmt3>
```

### Response
```
OK      # WROOM ready to receive frame data
ERROR   # Failed to prepare (invalid params or busy)
```

### Examples

**Example 1: All 4 channels active with RGB**
```bash
AT+LED_PREP=150,200,100,250,3,3,3,3
OK

# ESP32 WROOM now ready to receive:
# - Channel 0: 150 pixels, RGB format (450 bytes)
# - Channel 1: 200 pixels, RGB format (600 bytes)
# - Channel 2: 100 pixels, RGB format (300 bytes)
# - Channel 3: 250 pixels, RGB format (750 bytes)
# Total payload: 2,100 bytes + 12-byte header
```

**Example 2: Mixed RGB and RGBW formats**
```bash
AT+LED_PREP=100,0,150,200,3,3,4,4
OK

# Configuration:
# - Channel 0: 100 pixels, RGB (300 bytes)
# - Channel 1: Disabled (0 pixels)
# - Channel 2: 150 pixels, RGBW (600 bytes)
# - Channel 3: 200 pixels, RGBW (800 bytes)
# Total payload: 1,700 bytes + 12-byte header
```

**Example 3: Only channels 2 and 3 (legacy compatibility)**
```bash
AT+LED_PREP=0,0,500,300,3,3,3,3
OK

# Only channels 2 and 3 active:
# - Channel 2: 500 pixels, RGB (1,500 bytes)
# - Channel 3: 300 pixels, RGB (900 bytes)
```

### Implementation Details
- **Timeout**: 1000ms (configuration operation)
- **SPI Setup**: Configures SPI slave DMA for 4-channel frame reception
- **Frame Format**: 12-byte header + concatenated channel pixel data
- **Maximum Frame**: 19,212 bytes (12 header + 1200 pixels × 4 bytes × 4 channels)
- **Channel Allocation**: Dynamically allocates NeoPixelBus RMT instances for active channels
- **Memory Management**: Right-sized DMA buffers based on active channels and formats

### Error Conditions
- Invalid pixel counts (negative or > 1200)
- Invalid color format (not 3 or 4)
- SPI slave already busy with previous frame
- Insufficient memory for frame buffer allocation
- NeoPixelBus RMT channel allocation failure

### Channel Configuration
The command configures the WROOM's NeoPixelBus RMT output:

| Channel | RMT Unit | Protocol | GPIO |
|---------|----------|----------|------|
| 0 | RMT0 | WS2812/SK6812 | Configurable |
| 1 | RMT1 | WS2812/SK6812 | Configurable |
| 2 | RMT2 | WS2812/SK6812 | Configurable |
| 3 | RMT3 | WS2812/SK6812 | Configurable |

**Format Selection**:
- **3 (RGB)**: WS2812 protocol, 3 bytes per pixel (GRB order)
- **4 (RGBW)**: SK6812 protocol, 4 bytes per pixel (GRBW order)

---

## AT+LED_STATS

Returns LED controller statistics and current state.

### Request
```
AT+LED_STATS
```

### Response
```
+LED_STATS:SPI,<state>,<frames_ok>,<frames_error>,<crc_errors>
```

**Response Fields:**
- `state` (string): Current LED controller state: IDLE, PREP, RECEIVING, PROCESSING
- `frames_ok` (integer): Total successfully processed frames since boot
- `frames_error` (integer): Total frames that failed processing
- `crc_errors` (integer): Total frames with CRC checksum errors

### Example
```bash
AT+LED_STATS
+LED_STATS:SPI,IDLE,1247,3,0
OK

# Status: IDLE state, 1247 good frames, 3 errors, 0 CRC failures
```

### State Descriptions

| State | Description |
|-------|-------------|
| `IDLE` | Not processing, ready for new frame |
| `PREP` | Prepared and waiting for frame data |
| `RECEIVING` | Currently receiving frame via SPI |
| `PROCESSING` | Processing frame data to RMT channels |

---

## AT+LED_RESET

Resets the LED controller to idle state, clearing any ongoing operations.

### Request
```
AT+LED_RESET
```

### Response
```
OK      # LED controller reset successfully
ERROR   # Reset failed (should not occur)
```

### Example
```bash
AT+LED_RESET
OK

# LED controller now in IDLE state
# Any ongoing frame operations cancelled
```

### Use Cases
- Recovery from frame timeout or error conditions
- Clearing stuck SPI operations
- System initialization/cleanup
- Emergency stop of LED operations

### Implementation Details
- **Effect**: Stops SPI slave, clears frame buffers, resets RMT channels
- **Timing**: Immediate operation, no frame synchronization required
- **Safety**: Safe to call at any time, even during frame processing

---

## Unsolicited Result Codes (URCs)

### +LED_DONE

Sent automatically when the ESP32-H2 completes processing a LED frame.

```
+LED_DONE:<frame_id>
```

**Response Fields:**
- `frame_id` (integer): Frame sequence number for synchronization with ESP32-C5

#### Example
```bash
# After AT+LED_PREP and successful frame transmission:
+LED_DONE:123

# Frame 123 has been processed and output to RMT channels 2&3
```

#### Timing
- **Latency**: &lt;5µs from SPI reception complete to RMT output start
- **Synchronization**: Enables frame-locked rendering across both MCUs
- **Reliability**: Only sent after successful CRC verification and RMT setup

---

## Integration with NeoPixelBus

The LED commands integrate automatically with the NeoPixelBus framework on ESP32-C5:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h
void _sendLightPipePrepCommand() {
    // Collect pixel counts and formats from all 4 channels
    uint16_t px[4];
    uint8_t fmt[4];
    for (int i = 0; i < 4; i++) {
        px[i] = _channels[i].registered ? _channels[i].pixelCount : 0;
        fmt[i] = _channels[i].elementSize; // 3=RGB, 4=RGBW
    }

    // Check if configuration changed
    bool changed = false;
    for (int i = 0; i < 4; i++) {
        if (px[i] != _lastPx[i] || fmt[i] != _lastFmt[i]) {
            changed = true;
            break;
        }
    }
    if (!changed) return;

    // Update cache
    for (int i = 0; i < 4; i++) {
        _lastPx[i] = px[i];
        _lastFmt[i] = fmt[i];
    }

    // Send AT command with 8 parameters
    char cmd[128];
    snprintf(cmd, sizeof(cmd), "AT+LED_PREP=%u,%u,%u,%u,%u,%u,%u,%u",
             px[0], px[1], px[2], px[3], fmt[0], fmt[1], fmt[2], fmt[3]);

    bool ok = ATHost_sendATWaitOK(cmd, 1000); // 1000ms timeout
    if (ok) {
        ESP_LOGI(TAG, "Sent LED_PREP: px=[%u,%u,%u,%u] fmt=[%u,%u,%u,%u]",
                 px[0], px[1], px[2], px[3], fmt[0], fmt[1], fmt[2], fmt[3]);
        lightPipe.markLightPipeInitialized();
    } else {
        ESP_LOGW(TAG, "Failed to send LED_PREP to WROOM");
    }
}
```

### Automatic Frame Coordination

The complete LED frame coordination sequence:

1. **WLED Render**: Calculates full 4-channel frame on ESP32-C5
2. **Configuration Check**: Shared manager detects if channel setup changed
3. **AT+LED_PREP**: Sends 8-parameter command to configure WROOM
4. **Buffer Allocation**: WROOM allocates NeoPixelBus instances for active channels
5. **Frame Assembly**: C5 creates 12-byte header + concatenated channel data
6. **GPIO Handshake**: C5 waits for WROOM READY signal
7. **ParlIO Transmission**: 30MHz data stream to WROOM SPI slave
8. **Frame Validation**: WROOM verifies magic number and CRC16
9. **LED Output**: WROOM copies data to NeoPixelBus and triggers RMT output
10. **GPIO Complete**: WROOM signals DONE via MISO pin
11. **Next Frame**: Process repeats for next WLED frame update

This coordination ensures perfect synchronization between all 4 LED channels distributed across the dual-MCU system.

See also:
- [ESP32-C5 LightPipe State Management](../../esp32-c5-implementation.mdx#lightpipe-state-management) - How the C5 monitors WROOM health
- [ESP32 WROOM SPI LED Controller](../../esp32-wroom-implementation.mdx#spi-led-controller) - WROOM frame reception implementation