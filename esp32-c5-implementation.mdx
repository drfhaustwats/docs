---
title: "ESP32-C5 Implementation Guide"
description: "Complete guide to the ESP32-C5 main controller implementation with custom NeoPixelBus driver for distributed LED control"
---

# ESP32-C5 Implementation Guide

The ESP32-C5 serves as the main controller in the Watts v3 dual-MCU system, running WLED with a custom NeoPixelBus driver that distributes all four LED channels to an ESP32 WROOM module via high-speed ParlIO.

## Architecture Overview

The ESP32-C5 implementation uses a **fully distributed** architecture where all LED channels are transmitted to the ESP32 WROOM for output:

```
┌─────────────────────────────────────────────────────────┐
│                    ESP32-C5 Main Controller             │
├─────────────────────────────────────────────────────────┤
│  WLED Effects Engine                                    │
│  ├─ Channel 0 ──┐                                      │
│  ├─ Channel 1 ──┤                                      │
│  ├─ Channel 2 ──┤                                      │
│  └─ Channel 3 ──┘                                      │
│                 │                                       │
│  ┌──────────────▼─────────────────┐                    │
│  │   Shared Manager               │                    │
│  │  ├─ Channel Aggregation        │                    │
│  │  ├─ Frame Assembly             │                    │
│  │  └─ Protocol Coordination      │                    │
│  │                │                                     │
│  │  ┌─────────────▼──────────────┐                     │
│  │  │   30MHz ParlIO TX          │                     │
│  │  │   AT Command Protocol      │                     │
│  │  │   CRC16 Frame Validation   │                     │
│  │  │   GPIO Handshake Control   │                     │
│  │  └─────────────┬──────────────┘                     │
│  └────────────────┼────────────────────────────────────┘
│                   │ 30MHz ParlIO Stream                 │
│                   │ GPIO Handshake (MISO)               │
└───────────────────┼────────────────────────────────────┘
                    ▼
         ESP32 WROOM
         All 4 Channels → RMT Output
```

**Key Design Principle**: The ESP32-C5 has **no local RMT output**. All four channels (0-3) are processed by WLED on the C5, then transmitted as a unified frame to the ESP32 WROOM for parallel RMT output.

## Custom NeoPixelBus Driver

### Shared Manager Architecture

The `NeoEsp32ParlC5SharedManager` class manages all four LED channels through a singleton pattern, providing centralized frame assembly and ParlIO transmission:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h

class NeoEsp32ParlC5SharedManager {
private:
    static NeoEsp32ParlC5SharedManager* _instance;

    // Channel management
    struct ChannelInfo {
        uint8_t pin;
        uint16_t pixelCount;
        size_t elementSize;     // 3=RGB, 4=RGBW
        uint8_t* pixelBuffer;
        size_t bufferSize;
        bool dirty;
        bool registered;
    };

    ChannelInfo _channels[4];  // All 4 channels distributed to WROOM

    // Hardware interfaces
    parlio_tx_unit_handle_t _parlioTxUnit;
    pcnt_unit_handle_t _pcntUnit;

    // Frame buffer
    uint8_t* _h2FrameBuffer;   // DMA-capable frame buffer
    size_t _h2FrameSize;

    // AT command state tracking
    uint16_t _lastPx[4];       // Last pixel counts sent
    uint8_t _lastFmt[4];       // Last formats sent
};
```

### Channel Method Classes

Four identical method classes provide the standard NeoPixelBus API, all routing through the shared manager:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5X4Methods.h

// All channels route through shared manager → ParlIO → ESP32 WROOM
class NeoEsp32ParlC5Ch0Method;  // Channel 0 → Shared Manager → WROOM
class NeoEsp32ParlC5Ch1Method;  // Channel 1 → Shared Manager → WROOM
class NeoEsp32ParlC5Ch2Method;  // Channel 2 → Shared Manager → WROOM
class NeoEsp32ParlC5Ch3Method;  // Channel 3 → Shared Manager → WROOM
```

Each method class implements:
- `Begin()` - Register with shared manager
- `End()` - Unregister and cleanup
- `Update()` - Trigger frame transmission
- `SetPixelColor()` - Update pixel data with dirty tracking

## WLED Integration

### Bus Type Definitions

The system extends WLED's bus wrapper with ESP32-C5 ParlIO channel types:

```cpp
// File: components/wled/bus_wrapper.h

// RGB Channel Types (3 bytes per pixel)
#define I_32_PC5_CH0_3 63  // ParlIO Channel 0 RGB
#define I_32_PC5_CH1_3 64  // ParlIO Channel 1 RGB
#define I_32_PC5_CH2_3 65  // ParlIO Channel 2 RGB
#define I_32_PC5_CH3_3 66  // ParlIO Channel 3 RGB

// RGBW Channel Types (4 bytes per pixel)
#define I_32_PC5_CH0_4 67  // ParlIO Channel 0 RGBW
#define I_32_PC5_CH1_4 68  // ParlIO Channel 1 RGBW
#define I_32_PC5_CH2_4 69  // ParlIO Channel 2 RGBW
#define I_32_PC5_CH3_4 70  // ParlIO Channel 3 RGBW
```

### Bus Creation Logic

WLED automatically distributes LED strips across available channels using round-robin allocation:

```cpp
// File: components/wled/bus_wrapper.h

#if defined(CONFIG_IDF_TARGET_ESP32C5)
uint8_t channel = num % 4; // Round-robin: 0→1→2→3→0...

switch (busType) {
    case TYPE_WS2812_RGB:
        return I_32_PC5_CH0_3 + channel;  // Auto-distribute RGB
    case TYPE_SK6812_RGBW:
        return I_32_PC5_CH0_4 + channel;  // Auto-distribute RGBW
}
#endif
```

This ensures optimal load distribution when multiple LED strips are configured in WLED.

## Frame Synchronization Protocol

### AT Command Protocol

The shared manager coordinates with the ESP32 WROOM via the **AT+LED_PREP** command, which configures the WROOM to receive frame data:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h (lines 893-954)

void _sendH2PrepCommand(bool forceReset = false) {
    uint16_t px[4] = {0, 0, 0, 0};
    uint8_t fmt[4] = {4, 4, 4, 4}; // Default RGBW

    // Gather channel configuration
    for (int i = 0; i < 4; i++) {
        if (_channels[i].registered) {
            px[i] = _channels[i].pixelCount;
            fmt[i] = (_channels[i].elementSize == 3) ? 3 : 4; // 3=RGB, 4=RGBW
        }
    }

    // Optimization: only send if configuration changed
    bool changed = forceReset;
    if (!changed) {
        for (int i = 0; i < 4; i++) {
            if (px[i] != _lastPx[i] || fmt[i] != _lastFmt[i]) {
                changed = true;
                break;
            }
        }
    }

    if (!changed) return;

    // Update cache
    for (int i = 0; i < 4; i++) {
        _lastPx[i] = px[i];
        _lastFmt[i] = fmt[i];
    }

    // Dynamic buffer reallocation - triggered only on config change
    _allocateH2Buffer();

    // Send AT command with 8 parameters
    char cmd[128];
    snprintf(cmd, sizeof(cmd), "AT+LED_PREP=%u,%u,%u,%u,%u,%u,%u,%u",
             px[0], px[1], px[2], px[3], fmt[0], fmt[1], fmt[2], fmt[3]);

    bool ok = ATHost_sendATWaitOK(cmd, 1000); // 1000ms timeout

    if (ok) {
        ESP_LOGI(TAG, "%s LED_PREP: px=[%u,%u,%u,%u] fmt=[%u,%u,%u,%u]",
                 forceReset ? "Forced" : "Sent",
                 px[0], px[1], px[2], px[3], fmt[0], fmt[1], fmt[2], fmt[3]);
        _frameTransferActive = true;
    }
}
```

**AT+LED_PREP Command Format**:
```
AT+LED_PREP=<px0>,<px1>,<px2>,<px3>,<fmt0>,<fmt1>,<fmt2>,<fmt3>
```

Parameters:
- `px0-px3`: Pixel count for channels 0-3 (0 = channel disabled)
- `fmt0-fmt3`: Color format for channels 0-3 (3=RGB, 4=RGBW)

### Dynamic Buffer Management

The system implements an **intelligent buffer reallocation strategy** that optimizes memory usage:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h (lines 956-982)

void _allocateH2Buffer() {
    // Calculate needed size: header + sum of all active channel bytes
    size_t need = sizeof(led_frame_header_t);  // 12 bytes
    for (int i = 0; i < 4; i++) {
        if (_channels[i].registered) {
            need += (size_t)_channels[i].pixelCount * _channels[i].elementSize;
        }
    }
    if (need > MAX_TRANSFER) need = MAX_TRANSFER; // safety guard

    // Free old buffer if exists
    if (_h2FrameBuffer) {
        heap_caps_free(_h2FrameBuffer);
        _h2FrameBuffer = nullptr;
    }

    // Allocate DMA-capable aligned buffer
    _h2FrameBuffer = (uint8_t*)heap_caps_aligned_alloc(
        4, need, MALLOC_CAP_DMA | MALLOC_CAP_INTERNAL);
    _h2FrameSize = 0;

    if (_h2FrameBuffer) {
        ESP_LOGI(TAG, "Allocated WROOM frame buffer: %u bytes", (unsigned)need);
    } else {
        ESP_LOGE(TAG, "Failed to allocate WROOM frame buffer!");
    }
}
```

**Key Features**:
- **Triggered only on configuration changes**: Buffer is reallocated when pixel counts or formats change, not on every frame
- **Right-sized allocation**: Calculates exact size needed based on active channels
- **Memory safety**: Frees old buffer before allocating new one to prevent leaks
- **DMA-capable**: 4-byte aligned allocation in internal RAM for ParlIO DMA access
- **Fail-safe**: Respects MAX_TRANSFER limit (16,012 bytes) to prevent overruns

**Performance Impact**:
- Reallocation only occurs during WLED configuration changes (rare)
- Normal frame updates use the existing buffer (fast path)
- No memory waste - buffer size matches actual data requirements

### Frame Data Protocol

After sending AT+LED_PREP, the shared manager transmits a binary frame containing all pixel data:

```cpp
// Frame header structure (12 bytes)
typedef struct __attribute__((packed)) {
    uint16_t magic;        // 0x4C45 ("LE" - Little Endian marker)
    uint16_t ch0_pixels;   // Channel 0 pixel count
    uint16_t ch1_pixels;   // Channel 1 pixel count
    uint16_t ch2_pixels;   // Channel 2 pixel count
    uint16_t ch3_pixels;   // Channel 3 pixel count
    uint16_t crc16;        // CRC16-CCITT of payload
} led_frame_header_t;
```

**Frame Structure**:
```
┌──────────────────────────────────────────────┐
│ Header (12 bytes)                            │
│  - magic: 0x4C45                             │
│  - ch0_pixels, ch1_pixels, ch2_pixels, ch3_pixels
│  - crc16                                     │
├──────────────────────────────────────────────┤
│ Payload (variable length)                    │
│  - Channel 0 pixels (ch0_pixels × fmt[0])   │
│  - Channel 1 pixels (ch1_pixels × fmt[1])   │
│  - Channel 2 pixels (ch2_pixels × fmt[2])   │
│  - Channel 3 pixels (ch3_pixels × fmt[3])   │
└──────────────────────────────────────────────┘

Total size: 12 + sum(chN_pixels × fmtN) bytes
Maximum: 12 + (4000 × 4) = 16,012 bytes
```

### Frame Assembly

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h (lines 989-1021)

void _createH2Frame() {
    if (!_h2FrameBuffer) return;

    uint8_t* p = _h2FrameBuffer;

    // 1) Build header
    auto* h = (led_frame_header_t*)p;
    h->magic       = LED_FRAME_MAGIC;      // 0x4C45
    h->ch0_pixels  = _channels[0].registered ? _channels[0].pixelCount : 0;
    h->ch1_pixels  = _channels[1].registered ? _channels[1].pixelCount : 0;
    h->ch2_pixels  = _channels[2].registered ? _channels[2].pixelCount : 0;
    h->ch3_pixels  = _channels[3].registered ? _channels[3].pixelCount : 0;
    h->crc16       = 0; // Computed below
    p += sizeof(*h);

    // 2) Copy payload: CH0..CH3 consecutively
    size_t pay_len = 0;
    for (int ch = 0; ch < 4; ch++) {
        if (_channels[ch].registered && _channels[ch].pixelBuffer) {
            const size_t sz = (size_t)_channels[ch].pixelCount * _channels[ch].elementSize;
            memcpy(p, _channels[ch].pixelBuffer, sz);
            p += sz;
            pay_len += sz;
        }
    }

    // 3) Compute CRC over payload only
    const uint16_t crc = crc16_ccitt_update(0xFFFF,
        _h2FrameBuffer + sizeof(led_frame_header_t), pay_len);
    ((led_frame_header_t*)_h2FrameBuffer)->crc16 = crc;

    _h2FrameSize = sizeof(led_frame_header_t) + pay_len;
}
```

### GPIO Handshake Protocol

The system uses a **GPIO-based handshake** to ensure reliable frame synchronization between the C5 and WROOM:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h (lines 1025-1088)

void _updateH2Channels(void) {
    if (!_parlioTxUnit) return;
    _frameTransferActive = true;

    // 1. Wait for WROOM READY (GPIO HIGH) - max 300ms
    static int readyTimeoutCount = 0;
    uint32_t timeout = 300;
    uint32_t start = millis();

    while (gpio_get_level(getH2HandshakePin()) == 0) {
        if (millis() - start > timeout) {
            ESP_LOGE(TAG, "Timeout waiting for WROOM READY");
            _frameTransferActive = false;
            _framesSkipped++;
            readyTimeoutCount++;

            // Recovery logic: force reset after 3 timeouts
            if (readyTimeoutCount > 3) {
                forceLightPipeReset();
                readyTimeoutCount = 0;
            }
            return;
        }
        vTaskDelay(1);
    }

    readyTimeoutCount = 0; // Reset on success

    // 2. Transmit frame via ParlIO
    parlio_transmit_config_t txc = {};
    txc.idle_value = 0;
    ESP_ERROR_CHECK(parlio_tx_unit_transmit(_parlioTxUnit, _h2FrameBuffer,
                                             _h2FrameSize * 8, &txc));
    ESP_ERROR_CHECK(parlio_tx_unit_wait_all_done(_parlioTxUnit, -1));

    // 3. Wait for WROOM DONE (GPIO HIGH again) - max 3000ms
    start = millis();
    while (gpio_get_level(getH2HandshakePin()) == 0) {
        if (millis() - start > 3000) {
            ESP_LOGE(TAG, "Timeout waiting for WROOM DONE");
            _framesSkipped++;
            _frameTransferActive = false;
            return;
        }
        vTaskDelay(1);
    }

    _framesSent++;
    _frameTransferActive = false;
    _lastFrameTime = millis();
}
```

**Handshake Sequence**:
1. **C5 waits for WROOM READY**: GPIO (MISO pin) goes HIGH when WROOM is ready to receive
2. **C5 transmits frame**: ParlIO sends frame data at 30MHz
3. **C5 waits for WROOM DONE**: GPIO goes HIGH again when WROOM completes processing

**GPIO Pin**: `PINS.spi.miso` (configured as input with pull-down on C5)

### Hardware Error Recovery

The system includes multi-level error recovery:

```cpp
// Level 1: Force light pipe reset after 3 READY timeouts
if (readyTimeoutCount > 3) {
    forceLightPipeReset();  // Reset protocol state
}

// Level 2: Hardware reset of WROOM after 3 force resets
if (forceResetCount >= 3) {
    gpio_set_direction(WR_EN_PIN, GPIO_MODE_OUTPUT);  // GPIO 26
    gpio_set_level(WR_EN_PIN, 0);   // Assert reset (active LOW)
    vTaskDelay(pdMS_TO_TICKS(200));     // Hold 200ms
    gpio_set_level(WR_EN_PIN, 1);   // Release reset
    gpio_set_direction(WR_EN_PIN, GPIO_MODE_INPUT);
}
```

## LightPipe State Management

The ESP32-C5 includes a comprehensive state management system for monitoring the health and initialization status of the ESP32 WROOM ("LightPipe") connection. This ensures reliable LED output and automatic recovery from failures.

### LightPipeStateManager Class

The `LightPipeStateManager` is a singleton class that tracks the WROOM's operational state through heartbeat monitoring:

```cpp
// File: components/wled/lightpipe_state.h

class LightPipeStateManager {
public:
    static LightPipeStateManager& getInstance();

    // State management
    void onHeartbeatReceived(bool lightpipe_initialized);
    bool checkLightPipeStatus();
    bool needsReinit() const;
    void markLightPipeInitialized();

    // OTA handling
    void enterOTAMode();
    void exitOTAMode();
    bool isInOTA() const;

    // Status queries
    bool isAlive() const;
    bool isInitialized() const;
    const char* getStateString() const;

private:
    static constexpr uint32_t HEARTBEAT_TIMEOUT = 15000;  // 15 seconds
    static constexpr uint8_t MAX_MISSED = 3;              // 3 missed = dead

    uint32_t _startupTime;
    uint32_t _lastHeartbeat;
    bool _lightPipeAlive;
    bool _lightPipeInitialized;
    bool _needsReinit;
    uint8_t _missedHeartbeats;
    bool _inOTA;
    uint32_t _otaStartTime;
    bool _waitingForReboot;
    uint32_t _rebootWaitStart;
};
```

### Heartbeat Protocol

The WROOM sends periodic heartbeat messages to the C5 every **10 seconds**:

**Heartbeat Format**: `+H2_ALIVE:<state>`
- `+H2_ALIVE:0` - WROOM is alive but **not initialized** (no LED configuration loaded)
- `+H2_ALIVE:1` - WROOM is alive and **fully initialized** (ready for LED data)

**Monitoring Logic**:
```cpp
// File: components/wled/lightpipe_state.h (lines 31-58)

void onHeartbeatReceived(bool lightpipe_initialized) {
    if (_inOTA) return;  // Ignore heartbeats during OTA

    _lastHeartbeat = millis();

    // Detect recovery from reboot
    if (_waitingForReboot) {
        ESP_LOGI("LIGHTPIPE", "LightPipe back online after reboot (boot time: %lums)",
                 millis() - _rebootWaitStart);
        _waitingForReboot = false;
    }

    // Detect recovery from dead state
    if (!_lightPipeAlive) {
        ESP_LOGI("LIGHTPIPE", "LightPipe recovered (init_state=%d)", lightpipe_initialized);
    }

    _lightPipeAlive = true;
    _missedHeartbeats = 0;

    // Track initialization state changes
    bool wasInitialized = _lightPipeInitialized;
    _lightPipeInitialized = lightpipe_initialized;

    if (!lightpipe_initialized && wasInitialized) {
        ESP_LOGW("LIGHTPIPE", "LightPipe lost initialization (reboot detected)");
        _needsReinit = true;
    } else if (!lightpipe_initialized) {
        _needsReinit = true;
    }
}
```

### State Machine

The state manager implements five distinct states:

| State | Description | Conditions |
|-------|-------------|------------|
| `OTA_IN_PROGRESS` | WROOM firmware update in progress | `_inOTA == true` |
| `WAITING_REBOOT` | Waiting for WROOM to reboot after OTA | `_waitingForReboot == true` |
| `DEAD` | No heartbeat received within timeout | `!_lightPipeAlive` |
| `ALIVE_UNINIT` | Heartbeats received but not initialized | `_lightPipeAlive && !_lightPipeInitialized` |
| `ALIVE_READY` | Fully operational and ready for LED data | `_lightPipeAlive && _lightPipeInitialized` |

**State Query**:
```cpp
const char* getStateString() const {
    if (_inOTA) return "OTA_IN_PROGRESS";
    if (_waitingForReboot) return "WAITING_REBOOT";
    if (!_lightPipeAlive) return "DEAD";
    if (!_lightPipeInitialized) return "ALIVE_UNINIT";
    return "ALIVE_READY";
}
```

### Timeout Detection

The system continuously monitors heartbeat timing and declares the WROOM dead after **45 seconds** of silence:

```cpp
// File: components/wled/lightpipe_state.h (lines 66-115)

bool checkLightPipeStatus() {
    // During OTA: 5-minute timeout
    if (_inOTA) {
        if (millis() - _otaStartTime > 300000) {
            ESP_LOGE("LIGHTPIPE", "OTA timeout - forcing exit");
            _inOTA = false;
            _lightPipeAlive = false;
            _needsReinit = true;
        }
        return true;
    }

    // Waiting for reboot: 30-second timeout
    if (_waitingForReboot) {
        if (millis() - _rebootWaitStart > 30000) {
            ESP_LOGE("LIGHTPIPE", "LightPipe didn't come back after reboot");
            _waitingForReboot = false;
            _lightPipeAlive = false;
            _needsReinit = true;
            return false;
        }
        return true;
    }

    // Initial startup: 15-second grace period
    if (_lastHeartbeat == 0) {
        if (millis() - _startupTime > HEARTBEAT_TIMEOUT) {
            ESP_LOGE("LIGHTPIPE", "No initial heartbeat received");
            _needsReinit = true;
            _startupTime = millis();  // Reset for retry
            return false;
        }
        return true;
    }

    // Normal operation: 45-second timeout (3 x 15s)
    uint32_t elapsed = millis() - _lastHeartbeat;
    if (elapsed > HEARTBEAT_TIMEOUT) {
        _missedHeartbeats++;
        if (_missedHeartbeats >= MAX_MISSED) {
            if (_lightPipeAlive) {
                ESP_LOGE("LIGHTPIPE", "LightPipe heartbeat lost!");
                _lightPipeAlive = false;
                _lightPipeInitialized = false;
                _needsReinit = true;
            }
            return false;
        }
    }
    return true;
}
```

**Timeout Thresholds**:
- **Heartbeat interval**: 10 seconds (WROOM transmission rate)
- **Timeout per heartbeat**: 15 seconds (10s + 5s grace period)
- **Max missed heartbeats**: 3 consecutive misses
- **Total timeout**: 45 seconds before declaring WROOM dead
- **OTA timeout**: 5 minutes for firmware updates
- **Reboot timeout**: 30 seconds after OTA completion

### OTA Mode Handling

During over-the-air firmware updates, the state manager enters a special mode:

```cpp
// Enter OTA mode (suspend monitoring)
void enterOTAMode() {
    _inOTA = true;
    _otaStartTime = millis();
    ESP_LOGW("LIGHTPIPE", "Entering OTA mode - suspending heartbeat monitoring");
}

// Exit OTA mode (wait for reboot)
void exitOTAMode() {
    _inOTA = false;
    _lastHeartbeat = 0;
    _lightPipeAlive = false;
    _lightPipeInitialized = false;
    _waitingForReboot = true;
    _rebootWaitStart = millis();
    ESP_LOGI("LIGHTPIPE", "OTA complete - waiting for LightPipe reboot");
}
```

**OTA Sequence**:
1. C5 calls `enterOTAMode()` before starting firmware transfer
2. Heartbeat monitoring is suspended (WROOM won't send heartbeats during flash)
3. OTA data is transmitted to WROOM
4. C5 calls `exitOTAMode()` when transfer completes
5. System enters `WAITING_REBOOT` state with 30-second timeout
6. When first heartbeat arrives, WROOM is considered back online

### Integration with Shared Manager

The shared manager uses the state manager to determine when to reinitialize the WROOM:

```cpp
// Check if reinitialization is needed
if (lightPipe.needsReinit()) {
    ESP_LOGW(TAG, "Reinitializing LightPipe (state=%s)", lightPipe.getStateString());

    // Send AT+LED_PREP command to reconfigure
    snprintf(cmd, sizeof(cmd), "AT+LED_PREP=%u,%u,%u,%u,%u,%u,%u,%u",
             px[0], px[1], px[2], px[3], fmt[0], fmt[1], fmt[2], fmt[3]);
    _sendATCommand(cmd);

    // Mark as initialized
    lightPipe.markLightPipeInitialized();
    lightPipe.clearReinitFlag();
}
```

**Reinitialization Triggers**:
- WROOM sends `+H2_ALIVE:0` (not initialized)
- Heartbeat timeout expires (WROOM presumed rebooted)
- OTA mode completes (new firmware loaded)
- Initialization state lost unexpectedly

### Usage Example

```cpp
// Global instance (singleton pattern)
#define lightPipe LightPipeStateManager::getInstance()

// In AT response handler for +H2_ALIVE
void onH2Alive(bool initialized) {
    lightPipe.onHeartbeatReceived(initialized);
}

// In main loop
void loop() {
    // Check status
    lightPipe.checkLightPipeStatus();

    // Handle reinitialization
    if (lightPipe.needsReinit() && lightPipe.isAlive()) {
        // Send AT+LED_PREP to reconfigure
        sendLedPrepCommand();
        lightPipe.markLightPipeInitialized();
        lightPipe.clearReinitFlag();
    }

    // Only send frames when ready
    if (lightPipe.isAlive() && lightPipe.isInitialized()) {
        sendLedFrame();
    }
}
```

## Hardware Configuration

### ParlIO Interface

The ParlIO peripheral provides high-speed serial transmission to the ESP32 WROOM:

```cpp
// Configuration
#define C5_PARLIO_BITRATE_HZ 30000000  // 30MHz bitrate
#define MAX_TRANSFER 16012              // 12 header + 16000 payload max

parlio_tx_unit_config_t config = {
    .clk_src = PARLIO_CLK_SRC_DEFAULT,
    .resolution_hz = 30000000,          // 30MHz operation
    .data_width = 1,                    // 1-bit serial
    .idle_value = 0,                    // Idle low
    .trans_queue_depth = 4,
};

// GPIO Configuration
parlio_tx_gpio_config_t gpio_config = {
    .clk_out_pin = PINS.spi.sclk,      // Clock to WROOM (GPIO 23)
    .valid_pin = PINS.spi.cs,           // Frame valid signal (GPIO 28)
    .data_pins = {PINS.spi.mosi},       // Data pin (GPIO 8)
};
```

### GPIO Pin Assignments

| Pin | Function | Direction | Description |
|-----|----------|-----------|-------------|
| `PINS.spi.sclk` (GPIO 23) | ParlIO Clock | Output | 30MHz clock to ESP32 WROOM |
| `PINS.spi.cs` (GPIO 28) | ParlIO Valid | Output | Frame valid signal |
| `PINS.spi.mosi` (GPIO 8) | ParlIO Data | Output | Serial data transmission |
| `PINS.spi.miso` (GPIO 10) | Handshake | Input | WROOM READY/DONE signal |
| GPIO 26 | WR_EN | Output | WROOM reset/enable control |
| GPIO 27 | WR_BOOT | Output | WROOM boot mode control |

### Memory Management

The system uses a **dual-buffer architecture** optimized for both storage capacity and DMA performance:

#### Two-Buffer System

**1. Channel Pixel Buffers** (PSRAM - Storage Layer):
- Each of the 4 channel methods maintains its own pixel buffer
- Allocated in **PSRAM first** (larger capacity, lower cost)
- Falls back to internal RAM if PSRAM unavailable
- Used for storing pixel data written by WLED/NeoPixelBus
- Not DMA-capable (doesn't need to be - data is copied from here)

**2. Shared Frame Buffer** (Internal RAM - Transmission Layer):
- Single buffer managed by `NeoEsp32ParlC5SharedManager`
- Allocated in **DMA-capable internal RAM**
- Used for ParlIO transmission to WROOM
- Right-sized dynamically based on active channels
- Data is copied from channel pixel buffers into this unified frame

#### Channel Pixel Buffer Allocation

Each channel method allocates its own pixel buffer in PSRAM:

```cpp
// File: components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5X4Methods.h (lines 100-116)

void _allocateBuffers() {
    // NeoPixel buffer in PSRAM (doesn't need DMA - we memcpy from it)
    _pixelBuffer = static_cast<uint8_t*>(
        heap_caps_malloc(_bufferSize, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT)
    );
    if (!_pixelBuffer) {
        // Fallback to internal if no PSRAM
        _pixelBuffer = static_cast<uint8_t*>(
            heap_caps_malloc(_bufferSize, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT)
        );
    }
    if (_pixelBuffer) {
        memset(_pixelBuffer, 0, _bufferSize);
        ESP_LOGI(TAG, "Ch%d buffer in %s", CHANNEL_ID,
                 heap_caps_get_allocated_size(_pixelBuffer) ? "PSRAM" : "IRAM");
    }
}
```

**Why PSRAM for pixel buffers?**
- Pixel data is read-only during transmission (no real-time updates during DMA)
- PSRAM provides much larger capacity (8MB+) vs internal RAM (~400KB)
- Allows support for many more LEDs across 4 channels
- Slightly slower access is acceptable since data is copied once per frame

#### Shared Frame Buffer Allocation

Frame buffers are allocated in **DMA-capable internal RAM**:

```cpp
void _allocateH2Buffer() {
    // Calculate needed size: header + sum of all active channel bytes
    size_t need = sizeof(led_frame_header_t);  // 12 bytes
    for (int i = 0; i < 4; i++) {
        if (_channels[i].registered) {
            need += (size_t)_channels[i].pixelCount * _channels[i].elementSize;
        }
    }
    if (need > MAX_TRANSFER) need = MAX_TRANSFER;

    // Allocate DMA-capable aligned buffer
    _h2FrameBuffer = (uint8_t*)heap_caps_aligned_alloc(
        4, need, MALLOC_CAP_DMA | MALLOC_CAP_INTERNAL);

    if (_h2FrameBuffer) {
        ESP_LOGI(TAG, "Allocated WROOM frame buffer: %u bytes", (unsigned)need);
    }
}
```

**Why internal RAM for frame buffer?**
- ParlIO DMA requires direct memory access with strict timing
- Internal RAM provides fast, deterministic access for DMA controller
- Buffer size is kept minimal (only active channel data + header)
- DMA operations cannot access PSRAM directly on ESP32-C5

#### Data Flow Between Buffers

```
┌──────────────────────────────────────────────────────────────┐
│  WLED Effect Update (60 FPS)                                 │
└─────────────┬────────────────────────────────────────────────┘
              │
              ▼
┌──────────────────────────────────────────────────────────────┐
│  Channel Pixel Buffers (PSRAM - Storage Layer)               │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐         │
│  │ Ch0 Buffer   │ │ Ch1 Buffer   │ │ Ch2 Buffer   │         │
│  │ 150px × 3B   │ │ 200px × 3B   │ │ 100px × 3B   │ ...     │
│  │ = 450 bytes  │ │ = 600 bytes  │ │ = 300 bytes  │         │
│  └──────────────┘ └──────────────┘ └──────────────┘         │
└─────────────┬────────────────────────────────────────────────┘
              │ memcpy (on configuration change or frame update)
              ▼
┌──────────────────────────────────────────────────────────────┐
│  Shared Frame Buffer (Internal RAM - Transmission Layer)     │
│  ┌────────────┬────────────────────────────────────┐         │
│  │ Header(12) │ Ch0│Ch1│Ch2│Ch3 pixel data         │         │
│  │ + CRC      │ (concatenated in channel order)    │         │
│  └────────────┴────────────────────────────────────┘         │
│  Total: 12 + 450 + 600 + 300 + ... = dynamically sized       │
└─────────────┬────────────────────────────────────────────────┘
              │ ParlIO DMA @ 30MHz
              ▼
         ESP32 WROOM
```

**Key Insight**: The two-buffer system separates concerns:
- **Storage** (PSRAM) - Large capacity for holding all pixel data
- **Transmission** (Internal RAM) - Fast DMA access for real-time ParlIO output

## Performance Characteristics

### Timing Analysis

| Operation | Timing | Description |
|-----------|---------|------------|
| **AT+LED_PREP** | &lt;1ms | WROOM configuration command (only on channel changes) |
| **WROOM READY Wait** | &lt;300ms | GPIO handshake timeout |
| **ParlIO Transmission** | ~4.3ms | 16KB frame @ 30MHz (worst case) |
| **WROOM DONE Wait** | &lt;3000ms | WROOM processing + RMT output timeout |
| **Frame Rate** | ~60 FPS | Typical with 1000 pixels across 4 channels |

### Bandwidth Calculation

```
ParlIO Bitrate: 30 MHz
Bytes per second: 30,000,000 / 8 = 3,750,000 bytes/s

Maximum frame size: 16,012 bytes
Minimum transfer time: 16,012 / 3,750,000 = 4.27 ms

At 60 FPS (16.67ms per frame):
Available bandwidth: 16.67ms - 4.27ms = 12.4ms overhead
Overhead includes: AT commands, handshakes, WROOM processing
```

### CRC16 Validation

Frame integrity is verified using **CRC16-CCITT** (polynomial 0x1021):

```cpp
// CRC calculation over payload only (not header)
uint16_t crc16_ccitt_update(uint16_t crc, const uint8_t* data, size_t length) {
    for (size_t i = 0; i < length; i++) {
        crc = (crc << 8) ^ crc16_table[(crc >> 8) ^ data[i]];
    }
    return crc;
}

// Usage
const uint16_t crc = crc16_ccitt_update(0xFFFF,
    _h2FrameBuffer + sizeof(led_frame_header_t), pay_len);
```

## Configuration Examples

### Basic WLED Setup

Configure WLED to use the distributed LED system:

1. **Hardware Configuration**:
   - Configure LED outputs in WLED UI (any GPIOs work - they're placeholders)
   - The actual output happens on ESP32 WROOM via ParlIO
   - ParlIO uses `PINS.spi.mosi` (GPIO 8), `PINS.spi.sclk` (GPIO 23), `PINS.spi.cs` (GPIO 28)

2. **LED Strip Configuration**:
   ```json
   {
     "hw": {
       "led": {
         "total": 630,
         "maxpwr": 0,
         "ledma": 0,
         "ins": [
           {"start": 0, "len": 150, "pin": 18, "order": 0, "type": 22},  // Ch0
           {"start": 150, "len": 200, "pin": 19, "order": 0, "type": 22}, // Ch1
           {"start": 350, "len": 100, "pin": 26, "order": 0, "type": 22}, // Ch2
           {"start": 450, "len": 180, "pin": 25, "order": 0, "type": 22}  // Ch3
         ]
       }
     }
   }
   ```

3. **Channel Distribution**:
   - WLED creates strips 0-3
   - Each strip auto-assigns to channels 0-3 (round-robin)
   - All pixel data routes through shared manager → ParlIO → ESP32 WROOM

### Advanced Configuration

For high-performance applications, tune these parameters:

```cpp
// Frame buffer sizing
#define MAX_LED 4000                    // Maximum LEDs per channel
#define MAX_TRANSFER 16012              // Maximum frame size

// Timeout tuning
#define H2_READY_TIMEOUT_MS 300         // Wait for WROOM ready
#define H2_DONE_TIMEOUT_MS 3000         // Wait for WROOM processing complete

// Error recovery
#define MAX_READY_TIMEOUTS 3            // Force reset after N timeouts
#define MAX_FORCE_RESETS 3              // Hardware reset after N force resets

// Performance optimization
#define ENABLE_DIRTY_TRACKING 1         // Only transmit when pixel data changes
#define ENABLE_CONFIG_CACHING 1         // Skip AT+LED_PREP if config unchanged
```

## Build Configuration

### Required Components

Add these components to your main `CMakeLists.txt`:

```cmake
idf_component_register(
    SRCS "main.cpp"
    INCLUDE_DIRS ""
    REQUIRES
        arduino
        log
        esp_driver_parlio
        esp_driver_gpio
        esp_timer
    PRIV_REQUIRES
        ESPAsyncWebServer
        AsyncTCP
        athost
        NeoPixelBus
        FastLED
        wled
)
```

### ESP-IDF Configuration

Enable required drivers in `sdkconfig`:

```
CONFIG_IDF_TARGET_ESP32C5=y
CONFIG_SOC_PARLIO_SUPPORTED=y
CONFIG_ESP_DEFAULT_CPU_FREQ_240=y
CONFIG_FREERTOS_HZ=1000
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=4096
```

### Component Dependencies

The implementation requires these custom components:

- **NeoPixelBus**: Custom ESP32-C5 methods ([NeoEsp32ParlC5X4Methods.h](../src/Watts-ESP-IDF-C5/components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5X4Methods.h), [NeoEsp32ParlC5SharedManager.h](../src/Watts-ESP-IDF-C5/components/NeoPixelBus/src/internal/methods/NeoEsp32ParlC5SharedManager.h))
- **WLED**: Modified bus wrapper with C5 ParlIO support
- **ATHost**: AT command communication library
- **ESP-IDF**: v5.3+ with ESP32-C5 support

## Troubleshooting

### Common Issues

**Frame drops / skipped frames**:
- Check `_framesSkipped` counter via logs
- Verify GPIO handshake pin is correctly configured
- Ensure WROOM is running latest firmware with matching AT protocol

**CRC errors on WROOM**:
- Verify ParlIO clock integrity (check signal quality)
- Ensure frame buffer is DMA-aligned (4-byte minimum)
- Check for buffer overflow (respect MAX_TRANSFER limit)

**AT+LED_PREP failures**:
- Verify AT command timeout (1000ms default)
- Check UART communication between C5 and WROOM
- Ensure WROOM firmware supports 8-parameter LED_PREP format

**WROOM hardware resets**:
- Indicates persistent communication failures (3+ force resets)
- Check physical connections: ParlIO clock (GPIO 23), data (GPIO 8), valid (GPIO 28), handshake (GPIO 10)
- Verify WR_EN (GPIO 26) and WR_BOOT (GPIO 27) connections

### Debug Logging

Enable verbose logging to diagnose issues:

```cpp
// In NeoEsp32ParlC5SharedManager.h
static const char* TAG = "C5SharedMgr";

// Key log points:
ESP_LOGI(TAG, "Sent LED_PREP: px=[%u,%u,%u,%u] fmt=[%u,%u,%u,%u]", ...);
ESP_LOGE(TAG, "Timeout waiting for WROOM READY");
ESP_LOGE(TAG, "Timeout waiting for WROOM DONE");
ESP_LOGI(TAG, "Allocated WROOM frame buffer: %u bytes", size);
```

Monitor FreeRTOS task metrics:
```cpp
// Check for stack overflow or task starvation
vTaskGetInfo(NULL, &taskInfo, pdTRUE, eInvalid);
```

This implementation provides a robust, high-performance LED control system that leverages the ESP32-C5's processing power for WLED effects while utilizing the ESP32 WROOM's RMT peripherals for precise LED timing.

## See Also

- **[ESP32 WROOM Implementation Guide](esp32-wroom-implementation.mdx)** - Complete documentation of the WROOM secondary controller, including:
  - [Heartbeat System](esp32-wroom-implementation.mdx#heartbeat-system) - How the WROOM sends `+H2_ALIVE` heartbeats to the C5
  - [SPI LED Controller](esp32-wroom-implementation.mdx#spi-led-controller) - Frame reception and NeoPixelBus RMT output implementation
  - [AT Command Protocol](esp32-wroom-implementation.mdx#at-firmware-architecture) - Full AT command framework including `AT+LED_PREP`

- **[AT Protocol Documentation](at-protocol.mdx)** - Complete AT command reference and protocol specification

- **[Frame Data Protocol](frame-data-protocol.mdx)** - Deep dive into the binary frame format and CRC validation
