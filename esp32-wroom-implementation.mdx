---
title: "ESP32 WROOM Implementation Guide"
description: "Complete guide to the ESP32 WROOM secondary controller with AT firmware, BLE services, and SPI LED controller implementation"
---

# ESP32 WROOM Implementation Guide

The ESP32 WROOM serves as the secondary controller in the Watts v3 dual-MCU system, providing BLE connectivity and distributed LED control while communicating with the ESP32-C5 via AT commands over UART.

## Source Code Reference

| Component | File | Description |
|-----------|------|-------------|
| **Main Firmware** | [EspAt_firmware.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/EspAt_firmware.c) | Application entry, UART setup, task creation |
| **AT Parser** | [cat.h](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/cat.h) / [cat.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/cat.c) | Tiny-CAT AT command framework |
| **BLE Handler** | [ble_at_handler.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/ble_at_handler.c) | BLE AT command implementations |
| **GATT Services** | [gatt_svc.h](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gatt_svc.h) / [gatt_svc.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gatt_svc.c) | Dynamic GATT service management |
| **GAP** | [gap.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gap.c) | GAP advertising/connection |
| **LED Commands** | [at_led_commands.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/at_led_commands.c) | LED AT command handlers |
| **OTA** | [ota.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/ota.c) / [ota.h](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/ota.h) | Over-the-air update support |
| **Pin Mapping** | [pins.h](src/Watts-ESP-IDF-C5/components/pins/include/pins/pins.h) | Shared pin definitions |

**Target:** ESP32 (classic WROOM module) - `CONFIG_IDF_TARGET="esp32"` ([sdkconfig.defaults:255](src/ESP32%20Wroom%20LED%20Driver%20firmware/sdkconfig.defaults#L255))

## Architecture Overview

The ESP32 WROOM firmware implements a multi-subsystem architecture:

```
┌─────────────────────────────────────────────────────────────┐
│                    ESP32 WROOM Secondary                    │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │   Tiny-CAT      │  │   NimBLE Stack  │                  │
│  │   AT Parser     │  │   BLE Services  │                  │
│  │   (921.6 kbaud) │  │   GAP/GATT      │                  │
│  └─────────┬───────┘  └─────────┬───────┘                  │
│            │                    │                          │
│  ┌─────────▼────────────────────▼───────┐                  │
│  │         Main Application             │                  │
│  │    • Command Dispatch                │                  │
│  │    • Resource Management             │                  │
│  │    • Error Handling                  │                  │
│  └─────────┬────────────────────────────┘                  │
│            │                                               │
│  ┌─────────▼─────────────────┐  ┌─────────────────────────┐ │
│  │   SPI Slave LED Controller │  │  RMT LED Output        │ │
│  │   • Frame Reception        │  │  • 4 Channels          │ │
│  │   • CRC Validation         │  │  • WS2812 Protocol     │ │
│  │   • 30MHz Data Stream      │  │  • Synchronized Output │ │
│  └─────────────────────────────┘  └─────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## AT Firmware Architecture

### Tiny-CAT Framework

**Source:** [cat.h](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/cat.h) | [cat.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/cat.c)

The ESP32 WROOM firmware is built around the Tiny-CAT AT command parser, providing a robust and extensible command interface:

```cpp
// File: main/cat.h - Core framework structure
struct cat_command {
    const char *name;                    // Command name (e.g., "+BLEINIT")
    cat_cmd_write_handler write;         // AT+CMD=value handler
    cat_cmd_read_handler read;           // AT+CMD? handler  
    cat_cmd_run_handler run;             // AT+CMD handler
    cat_cmd_test_handler test;           // AT+CMD=? handler
    struct cat_variable const *var;     // Associated variables
    size_t var_num;                     // Variable count
    bool need_all_vars;                 // Validation requirement
};
```

**Parser State Machine:**
The Tiny-CAT parser implements a finite state machine with 15+ states for robust command processing:
- `CAT_STATE_IDLE` - Waiting for AT commands
- `CAT_STATE_PARSE_COMMAND_CHAR` - Command parsing
- `CAT_STATE_WRITE_LOOP` - Parameter processing
- `CAT_STATE_HOLD` - Suspended state (for OTA operations)

### Main Application Structure

**File**: `main/EspAt_firmware.c`

**Initialization Sequence:**
```cpp
void app_main(void) {
    // 1. Initialize NVS flash
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    
    // 2. Configure UART for AT communication
    uart_config_t uart_config = {
        .baud_rate = 921600,                     // 921.6 kbaud
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,   // No flow control
    };
    
    // 3. Register all AT commands
    register_all_commands();
    
    // 4. Initialize SPI LED controller
    spi_led_controller_init();
    
    // 5. Initialize BLE stack
    nimble_port_init();
    
    // 6. Start AT command processing task
    xTaskCreatePinnedToCore(cat_task, "cat_task", 4096, NULL, 6, NULL, 1);
    
    // 7. Validate OTA boot state
    verify_running_partition();
}
```

### FreeRTOS Task Structure

**Primary Tasks:**

1. **cat_task** (Priority 6, 4KB stack, pinned to Core 1):
   ```cpp
   void cat_task(void *arg) {
       while (1) {
           cat_service();           // Process AT commands
           vTaskDelay(pdMS_TO_TICKS(1));  // 1ms polling
       }
   }
   ```

2. **spi_recv_task** (Priority 12, 4KB stack):
   ```cpp
   void spi_recv_task(void *arg) {
       for (;;) {
           spi_slave_transaction_t *rtrans;
           if (spi_slave_get_trans_result(SPI_HOST, &rtrans, portMAX_DELAY) == ESP_OK) {
               uint8_t *frame_buf = (uint8_t*)rtrans->rx_buffer;
               xQueueSend(controller->frame_queue, &frame_buf, 0);
           }
       }
   }
   ```

3. **led_update_task** (Priority 12, 4KB stack):
   ```cpp
   void led_update_task(void *arg) {
       uint8_t *frame_buffer;
       while (xQueueReceive(controller->frame_queue, &frame_buffer, portMAX_DELAY)) {
           process_led_frame(frame_buffer);
           // Re-queue buffer for next reception
           spi_slave_queue_trans(SPI_HOST, &trans_desc, portMAX_DELAY);
       }
   }
   ```

4. **ble_host_task** (NimBLE managed):
   - Runs `nimble_port_run()`
   - Handles BLE stack operations
   - Managed by NimBLE FreeRTOS integration

5. **heartbeat_timer** (ESP Timer - 10 second interval):
   ```cpp
   static void heartbeat_timer_callback(void* arg) {
       if (h2_system_initialized) {
           write_to_at_console("+H2_ALIVE:1\r\n");
       } else {
           write_to_at_console("+H2_ALIVE:0\r\n");
       }
   }
   ```

### Heartbeat System

The WROOM firmware implements a periodic heartbeat mechanism to allow the ESP32-C5 to monitor its health and initialization status.

**Heartbeat Configuration**:
```cpp
// File: main/EspAt_firmware.c

#define HEARTBEAT_INTERVAL_US (10000000)  // 10 seconds

static esp_timer_handle_t heartbeat_timer = NULL;
static bool h2_system_initialized = false;

// Timer configuration
const esp_timer_create_args_t heartbeat_timer_args = {
    .callback = &heartbeat_timer_callback,
    .name = "heartbeat"
};
```

**Initialization**:
```cpp
// Create and start timer during app_main()
ESP_ERROR_CHECK(esp_timer_create(&heartbeat_timer_args, &heartbeat_timer));
ESP_ERROR_CHECK(esp_timer_start_periodic(heartbeat_timer, HEARTBEAT_INTERVAL_US));
```

**Heartbeat States**:

| Message | Meaning | Condition |
|---------|---------|-----------|
| `+H2_ALIVE:0` | WROOM alive but **not initialized** | `h2_system_initialized == false` |
| `+H2_ALIVE:1` | WROOM alive and **fully initialized** | `h2_system_initialized == true` |

**Initialization Flag Management**:

The `h2_system_initialized` flag is set to `true` when the WROOM has received and processed the `AT+LED_PREP` command, indicating it's ready to receive LED frame data:

```cpp
// File: main/at_led_commands.c

cat_return_state at_led_prep(const struct cat_command *cmd,
                             const uint8_t *data, size_t size, size_t args_num) {
    // Parse parameters: px[0-3], fmt[0-3]
    uint16_t px[4];
    uint8_t fmt[4];

    // ... parameter parsing ...

    // Configure SPI LED controller
    esp_err_t ret = spi_led_controller_config(px, fmt);
    if (ret != ESP_OK) {
        return CAT_RETURN_STATE_ERROR;
    }

    // Mark system as initialized
    h2_system_initialized = true;

    return CAT_RETURN_STATE_OK;
}
```

**C5 Integration**:

The ESP32-C5 receives these heartbeat messages via UART and processes them through the [LightPipeStateManager](esp32-c5-implementation.mdx#lightpipe-state-management):

```cpp
// C5 side: Parse +H2_ALIVE messages
void onH2AliveMessage(const char* message) {
    // Extract state: +H2_ALIVE:0 or +H2_ALIVE:1
    bool initialized = (message[10] == '1');

    // Update state manager
    lightPipe.onHeartbeatReceived(initialized);
}
```

**Heartbeat Monitoring**:
- **Transmission interval**: Every 10 seconds
- **C5 timeout**: 15 seconds per heartbeat + 5s grace period
- **C5 max missed**: 3 consecutive heartbeats (45 seconds total)
- **Recovery**: C5 automatically reinitializes WROOM when heartbeat resumes

**Reinitialization Triggers**:

The WROOM resets `h2_system_initialized` to `false` in these scenarios:
1. **System boot/reboot**: Flag initializes to `false`
2. **LED configuration change**: When new `AT+LED_PREP` is received, flag is cleared then set again
3. **Error recovery**: If the SPI LED controller encounters a fatal error

This automatic state reporting allows the C5 to detect WROOM reboots and automatically send a new `AT+LED_PREP` command to restore LED functionality without manual intervention.

## BLE Service Implementation

### NimBLE Integration

**Source:** [ble_at_handler.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/ble_at_handler.c) | [gatt_svc.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gatt_svc.c) | [gap.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gap.c)

**Initialization Flow:**
```cpp
// File: main/ble_at_handler.c - Line 281
static bool ble_initialized = false;

cat_return_state at_cmd_bleinit(const struct cat_command *cmd,
                                 const uint8_t *data, size_t size, size_t args_num) {
    if (ble_initialized) return CAT_RETURN_STATE_OK;
    
    int mode = atoi((const char *)data);
    if (mode != 2) return CAT_RETURN_STATE_ERROR;  // Only server mode
    
    // Initialize GATT services
    gatt_svc_init();
    gap_init();
    
    // Start BLE host task
    nimble_port_freertos_init(ble_host_task);
    
    // Wait for synchronization with 5-second timeout
    int timeout = 50;
    while (!ble_hs_synced() && timeout > 0) {
        vTaskDelay(pdMS_TO_TICKS(100));
        timeout--;
    }
    
    if (!ble_hs_synced()) {
        ESP_LOGE(TAG, "BLE host sync timeout");
        return CAT_RETURN_STATE_ERROR;
    }
    
    ble_initialized = true;
    return CAT_RETURN_STATE_OK;
}
```

### Dynamic GATT Service Management

**Source:** [gatt_svc.h](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gatt_svc.h) | [gatt_svc.c](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/gatt_svc.c)

**Service Table Structure:**
```cpp
// File: main/gatt_svc.h - Lines 18-43
typedef struct {
    struct ble_gatt_svc_def *svc_def;   // NimBLE service definition
    struct ble_gatt_chr_def *chr_defs;  // Characteristic definitions
    ble_uuid16_t *uuid_ptr;             // Service UUID object
    uint16_t uuid;                      // 16-bit UUID value
    char name[20];                      // Human-readable name
    bool in_use;                        // Allocation flag
} dynamic_service_entry_t;

typedef struct {
    ble_uuid16_t *uuid_ptr;             // Characteristic UUID
    uint16_t uuid;                      // 16-bit UUID value
    uint8_t properties;                 // BLE properties (R/W/N/I)
    char name[20];                      // Name
    bool in_use;                        // Allocation flag
    uint8_t value[128];                 // Data storage
    uint16_t val_len;                   // Current data length
    bool notify_enabled;                // Notification state
    uint16_t conn_handle;               // Connection handle
    uint16_t val_handle;                // Attribute handle
} dynamic_char_entry_t;

// Global tables: 10 services × 10 characteristics = 100 total
static dynamic_service_entry_t service_table[MAX_SERVICES];      // MAX_SERVICES = 10
static dynamic_char_entry_t char_table[MAX_SERVICES][MAX_CHARS_PER_SVC];  // MAX_CHARS_PER_SVC = 10
```

**Service Creation Example:**
```cpp
// File: main/ble_at.c - Lighting service definition
#define LIGHTING_SERVICE_UUID        0x1234
#define LIGHTING_POWER_CHAR_UUID     0x1235
#define LIGHTING_BRIGHTNESS_CHAR_UUID 0x1236
#define LIGHTING_PRESET_CHAR_UUID    0x1237
#define LIGHTING_COLOR_CHAR_UUID     0x1238

// Create lighting control service
void create_lighting_service() {
    // Add service
    at_ble_addsvc(0x1234, "Lighting Control");
    
    // Add characteristics
    at_ble_addchar(0, 0x1235, BLE_GATT_CHR_PROP_READ | BLE_GATT_CHR_PROP_WRITE, "Power");
    at_ble_addchar(0, 0x1236, BLE_GATT_CHR_PROP_WRITE, "Brightness");
    at_ble_addchar(0, 0x1237, BLE_GATT_CHR_PROP_WRITE, "Preset");
    at_ble_addchar(0, 0x1238, BLE_GATT_CHR_PROP_WRITE, "Color");
}
```

### BLE AT Commands

**Core BLE Command Set:**

1. **AT+BLEINIT=2** - Initialize BLE server mode
2. **AT+BLENAME="name"** - Set device name
3. **AT+BLEADVSTART** - Start advertising
4. **AT+BLEADVSTOP** - Stop advertising
5. **AT+BLEADDSVC=uuid,name** - Add dynamic service
6. **AT+BLEADDCHAR=svc,uuid,props,name** - Add characteristic
7. **AT+BLEWRITE=svc,char,"hexdata"** - Write characteristic value
8. **AT+BLEREAD=svc,char** - Read characteristic value
9. **AT+BLESVC** - List all services
10. **AT+BLECHAR=svc** - List service characteristics

**GATT Access Handler:**
```cpp
int dynamic_gatt_access_cb(uint16_t conn, uint16_t attr, 
                          struct ble_gatt_access_ctxt *ctxt, void *arg) {
    uint8_t svc_idx = (uintptr_t)arg >> 8;
    uint8_t chr_idx = (uintptr_t)arg & 0xFF;
    
    switch (ctxt->op) {
        case BLE_GATT_ACCESS_OP_READ_CHR:
            os_mbuf_append(ctxt->om, char_table[svc_idx][chr_idx].value, 
                          char_table[svc_idx][chr_idx].val_len);
            
            // Send URC notification to C5
            printf("+BLEGATTSREAD:%d,%d,\"%s\"\r\n", svc_idx, chr_idx, 
                   hex_string(char_table[svc_idx][chr_idx].value, 
                             char_table[svc_idx][chr_idx].val_len));
            break;
            
        case BLE_GATT_ACCESS_OP_WRITE_CHR:
            uint16_t len = OS_MBUF_PKTLEN(ctxt->om);
            if (len > sizeof(char_table[svc_idx][chr_idx].value)) {
                return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
            }
            
            os_mbuf_copydata(ctxt->om, 0, len, char_table[svc_idx][chr_idx].value);
            char_table[svc_idx][chr_idx].val_len = len;
            
            // Send URC notification to C5
            printf("+BLEGATTSRECV:\"%s\"\r\n", 
                   hex_string(char_table[svc_idx][chr_idx].value, len));
            break;
    }
    
    return 0;
}
```

### GAP Management

**Advertising Configuration:**
```cpp
// File: main/gap.c
void start_advertising() {
    struct ble_hs_adv_fields fields;
    memset(&fields, 0, sizeof(fields));
    
    // Device name
    fields.name = ble_svc_gap_device_name();
    fields.name_len = strlen(fields.name);
    fields.name_is_complete = 1;
    
    // Service UUIDs from active services
    uint16_t service_uuids[MAX_SERVICES];
    int num_services = get_active_service_uuids(service_uuids);
    if (num_services > 0) {
        fields.uuids16 = service_uuids;
        fields.num_uuids16 = num_services;
        fields.uuids16_is_complete = 1;
    }
    
    // Set advertising data
    ble_gap_adv_set_fields(&fields);
    
    // Start advertising
    struct ble_gap_adv_params adv_params = {0};
    adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
    adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
    
    ble_gap_adv_start(BLE_OWN_ADDR_PUBLIC, NULL, BLE_HS_FOREVER,
                      &adv_params, gap_event_handler, NULL);
}
```

## SPI LED Controller

The WROOM firmware implements a sophisticated SPI slave LED controller that receives LED frame data from the ESP32-C5 via ParlIO-to-SPI bridge and outputs to four independent LED channels using RMT.

### Architecture Overview

The SPI LED controller uses a **dual-protocol architecture**:

```
┌────────────────────────────────────────────────────────┐
│                ESP32-C5 (Master)                        │
│  ParlIO TX (30MHz) → GPIO Parallel Output              │
└───────────────────┬────────────────────────────────────┘
                    │ 8-bit parallel data stream
                    │ GPIO handshake (MISO)
┌───────────────────▼────────────────────────────────────┐
│                ESP32 WROOM (Slave)                      │
│  ┌──────────────────────────────────────────────────┐  │
│  │  SPI Slave Receiver (HSPI)                       │  │
│  │  • 8-bit parallel input mapped to SPI            │  │
│  │  • DMA frame buffering                           │  │
│  │  • CRC16 validation                              │  │
│  └────────┬─────────────────────────────────────────┘  │
│           │                                             │
│  ┌────────▼─────────────────────────────────────────┐  │
│  │  NeoPixelBus RMT Output (4 channels)            │  │
│  │  • CH0: RMT0 → WS2812/SK6812 protocol           │  │
│  │  • CH1: RMT1 → WS2812/SK6812 protocol           │  │
│  │  • CH2: RMT2 → WS2812/SK6812 protocol           │  │
│  │  • CH3: RMT3 → WS2812/SK6812 protocol           │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────┘
```

**Data Flow**:
1. C5 sends frame via 30MHz ParlIO (parallel output)
2. WROOM receives via HSPI (parallel pins mapped to SPI peripheral)
3. Frame validated and split into 4 channel buffers
4. Each channel output via dedicated RMT peripheral using NeoPixelBus

### SPI Slave Configuration

**Hardware Pin Mapping:**
```cpp
// File: main/spi_led_controller.h

#define SPI_HOST         HSPI_HOST          // SPI2 peripheral
#define PIN_SPI_SCLK     PINS.spis.sck      // Clock from C5
#define PIN_SPI_MOSI     PINS.spis.mosi     // Data from C5
#define PIN_SPI_CS       PINS.spis.cs       // Chip select/Valid from C5
#define PIN_SPI_MISO     PINS.spis.miso     // Handshake signal to C5

// LED output pins (all 4 channels)
#define LED_CH0_GPIO     PINS.led4.data[0]  // RMT Channel 0
#define LED_CH1_GPIO     PINS.led4.data[1]  // RMT Channel 1
#define LED_CH2_GPIO     PINS.led4.data[2]  // RMT Channel 2
#define LED_CH3_GPIO     PINS.led4.data[3]  // RMT Channel 3
```

**SPI Bus Initialization:**
```cpp
// File: main/spi_led_controller.cpp

spi_bus_config_t buscfg = {
    .mosi_io_num = PIN_SPI_MOSI,
    .miso_io_num = PIN_SPI_MISO,         // Bidirectional for handshake
    .sclk_io_num = PIN_SPI_SCLK,
    .max_transfer_sz = SPI_LED_MAX_SEGMENT,  // 12 + (1200 × 4 × 4) = 19,212 bytes
    .flags = SPICOMMON_BUSFLAG_SLAVE
};

spi_slave_interface_config_t slvcfg = {
    .mode = 0,                            // CPOL=0, CPHA=0
    .spics_io_num = PIN_SPI_CS,
    .queue_size = 7,                      // Transaction queue depth
    .flags = 0,
    .post_setup_cb = NULL,
    .post_trans_cb = NULL
};

ESP_ERROR_CHECK(spi_slave_initialize(SPI_HOST, &buscfg, &slvcfg, SPI_DMA_CH_AUTO));
```

**Maximum Capacities**:
- **Max pixels per channel**: 1200
- **Pixel formats**: RGB (3 bytes) or RGBW (4 bytes)
- **Max frame size**: 12 + (1200 × 4 × 4) = **19,212 bytes**
- **SPI transfer rate**: Driven by C5's 30MHz ParlIO clock

### Frame Protocol

The WROOM receives the same frame format as transmitted by the C5:

```cpp
// File: main/spi_led_controller.h

#define LED_FRAME_MAGIC 0x4C45  // 'LE'

typedef struct __attribute__((packed)) {
    uint16_t magic;        // 0x4C45
    uint16_t ch0_pixels;   // Channel 0 pixel count
    uint16_t ch1_pixels;   // Channel 1 pixel count
    uint16_t ch2_pixels;   // Channel 2 pixel count
    uint16_t ch3_pixels;   // Channel 3 pixel count
    uint16_t crc16;        // CRC16-CCITT of payload only
} led_frame_header_t;
```

**Frame Structure** (identical to C5 transmission):
```
┌──────────────────────────────────────────────┐
│ Header (12 bytes)                            │
│  - magic: 0x4C45                             │
│  - ch0_pixels, ch1_pixels, ch2_pixels, ch3_pixels
│  - crc16                                     │
├──────────────────────────────────────────────┤
│ Payload (variable length)                    │
│  - Channel 0 pixels (ch0_pixels × fmt[0])   │
│  - Channel 1 pixels (ch1_pixels × fmt[1])   │
│  - Channel 2 pixels (ch2_pixels × fmt[2])   │
│  - Channel 3 pixels (ch3_pixels × fmt[3])   │
└──────────────────────────────────────────────┘
```

See [ESP32-C5 Frame Data Protocol](esp32-c5-implementation.mdx#frame-data-protocol) for complete frame format details.

### Controller State Management

**Controller Structure:**
```cpp
// File: main/spi_led_controller.h

struct led_controller_t {
    // Channel configuration
    uint16_t pixels[4];                // Pixels per channel (set by AT+LED_PREP)
    uint8_t format[4];                 // Format per channel (3=RGB, 4=RGBW)

    // Frame buffers
    uint8_t* working_frame;            // DMA-capable frame buffer
    size_t working_frame_size;         // Buffer capacity in bytes

    // SPI transaction management
    spi_slave_transaction_t trans[2];  // Dual-buffer for continuous reception
    uint8_t t_idx;                     // Current transaction index (toggles 0/1)
    seg_state_t seg_state;             // Current segment being received
};
```

**Segment States:**
```cpp
typedef enum {
    SEG_HDR  = 0,  // Receiving header
    SEG_CH0  = 1,  // Receiving channel 0 data
    SEG_CH1  = 2,  // Receiving channel 1 data
    SEG_CH2  = 3,  // Receiving channel 2 data
    SEG_CH3  = 4   // Receiving channel 3 data
} seg_state_t;
```

### NeoPixelBus Integration

The controller uses **NeoPixelBus** library with RMT backend for precise WS2812/SK6812 timing:

**Type-Erased Strip Management:**
```cpp
// File: main/spi_led_controller.cpp

// Abstract interface for different strip types
struct IStrip {
    virtual void begin() = 0;
    virtual bool canShow() = 0;
    virtual void show() = 0;
    virtual void dirty() = 0;
    virtual uint8_t* pixels() = 0;
};

// Concrete wrappers for RGB and RGBW strips
static IStrip* strip_rgb[4]  = {nullptr, nullptr, nullptr, nullptr};
static IStrip* strip_rgbw[4] = {nullptr, nullptr, nullptr, nullptr};
```

**Strip Factory Functions:**
```cpp
// RGB strips (WS2812 protocol via RMT)
static IStrip* make_rgb_strip(int ch, uint16_t pixels, gpio_num_t pin) {
    switch (ch) {
        case 0: return new StripWrap<NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt0Ws2812xMethod>>(
                    new NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt0Ws2812xMethod>(pixels, pin));
        case 1: return new StripWrap<NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt1Ws2812xMethod>>(
                    new NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt1Ws2812xMethod>(pixels, pin));
        case 2: return new StripWrap<NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt2Ws2812xMethod>>(
                    new NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt2Ws2812xMethod>(pixels, pin));
        case 3: return new StripWrap<NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt3Ws2812xMethod>>(
                    new NeoPixelBus<NeoGrbFeature, NeoEsp32Rmt3Ws2812xMethod>(pixels, pin));
    }
}

// RGBW strips (SK6812 protocol via RMT)
static IStrip* make_rgbw_strip(int ch, uint16_t pixels, gpio_num_t pin) {
    switch (ch) {
        case 0: return new StripWrap<NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt0Sk6812Method>>(
                    new NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt0Sk6812Method>(pixels, pin));
        case 1: return new StripWrap<NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt1Sk6812Method>>(
                    new NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt1Sk6812Method>(pixels, pin));
        case 2: return new StripWrap<NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt2Sk6812Method>>(
                    new NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt2Sk6812Method>(pixels, pin));
        case 3: return new StripWrap<NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt3Sk6812Method>>(
                    new NeoPixelBus<NeoGrbwFeature, NeoEsp32Rmt3Sk6812Method>(pixels, pin));
    }
}
```

**Dynamic Strip Allocation:**

When `AT+LED_PREP` is received, the controller dynamically allocates NeoPixelBus instances for active channels:

```cpp
// File: main/at_led_commands.c

void controller_set_geometry(const uint16_t px[4], const uint8_t bpp[4]) {
    static gpio_num_t pins[4] = {LED_CH0_GPIO, LED_CH1_GPIO, LED_CH2_GPIO, LED_CH3_GPIO};

    for (int ch = 0; ch < 4; ch++) {
        // Clean up old strips
        delete strip_rgb[ch];
        delete strip_rgbw[ch];
        strip_rgb[ch] = nullptr;
        strip_rgbw[ch] = nullptr;

        // Skip inactive channels
        if (px[ch] == 0) continue;

        // Create new strip based on format
        if (bpp[ch] == PIXEL_FORMAT_RGB) {
            strip_rgb[ch] = make_rgb_strip(ch, px[ch], pins[ch]);
            strip_rgb[ch]->begin();
        } else if (bpp[ch] == PIXEL_FORMAT_RGBW) {
            strip_rgbw[ch] = make_rgbw_strip(ch, px[ch], pins[ch]);
            strip_rgbw[ch]->begin();
        }
    }
}
```

**Result**: Each active channel gets a properly configured NeoPixelBus instance with the correct RMT channel, GPIO pin, pixel count, and color format.

### GPIO Handshake Protocol

The WROOM uses the MISO pin for bidirectional handshake signaling with the C5:

**Handshake Sequence** (WROOM perspective):
1. **Signal READY**: Set MISO HIGH when ready to receive frame
2. **Receive frame**: C5 transmits frame via ParlIO→SPI
3. **Process frame**: Validate CRC, copy to channel buffers
4. **Signal DONE**: Set MISO HIGH when processing complete

This corresponds to the C5's handshake protocol documented in [GPIO Handshake Protocol](esp32-c5-implementation.mdx#gpio-handshake-protocol).

### Frame Reception and LED Output

The complete receive-and-display flow:

```cpp
// Simplified pseudocode of frame processing

void spi_receive_task() {
    while (1) {
        // 1. Signal ready
        gpio_set_level(PIN_SPI_MISO, 1);

        // 2. Wait for SPI frame
        spi_slave_transaction_t trans;
        spi_slave_transmit(SPI_HOST, &trans, portMAX_DELAY);

        // 3. Signal processing (MISO LOW during processing)
        gpio_set_level(PIN_SPI_MISO, 0);

        // 4. Validate frame
        led_frame_header_t* header = (led_frame_header_t*)working_frame;
        if (header->magic != LED_FRAME_MAGIC) continue;

        // 5. Verify CRC
        uint8_t* payload = working_frame + sizeof(led_frame_header_t);
        uint16_t computed_crc = crc16_ccitt(payload, payload_size);
        if (computed_crc != header->crc16) continue;

        // 6. Copy data to NeoPixelBus buffers
        uint8_t* src = payload;
        for (int ch = 0; ch < 4; ch++) {
            if (!channel_active(ch)) continue;

            size_t bytes = pixels[ch] * format[ch];
            uint8_t* dest = get_strip_pixels(ch);
            memcpy(dest, src, bytes);
            src += bytes;

            // Mark strip dirty for output
            mark_strip_dirty(ch);
        }

        // 7. Wait for all RMT channels idle
        wait_all_rmt_idle();

        // 8. Trigger synchronized LED output
        for (int ch = 0; ch < 4; ch++) {
            if (channel_active(ch)) {
                show_strip(ch);  // NeoPixelBus::Show()
            }
        }

        // 9. Signal done
        gpio_set_level(PIN_SPI_MISO, 1);
    }
}
```

**Key Operations**:
- **Frame reception**: DMA-based SPI slave reception
- **Validation**: Magic number + CRC16-CCITT check
- **Data distribution**: Channel pixel data copied to NeoPixelBus buffers
- **Synchronized output**: All 4 RMT channels output simultaneously
- **Handshake signaling**: GPIO feedback to C5 for flow control

### RMT LED Output

**RMT Channel Configuration:**
```cpp
// File: main/spi_led_controller.c
rmt_tx_channel_config_t tx_config = {
    .clk_src = RMT_CLK_SRC_DEFAULT,
    .gpio_num = (i == 0) ? RMT_CH2_GPIO : RMT_CH3_GPIO,  // GPIO 27, 26
    .mem_block_symbols = 48,               // 48 symbols (384 bytes)
    .resolution_hz = 32000000,             // 32 MHz for precise timing
    .trans_queue_depth = 8,                // 8 pending transactions
    .intr_priority = 3,                    // High priority
    .flags.invert_out = false,             // Normal polarity
    .flags.with_dma = true                 // Enable DMA
};
```

**WS2812 Protocol Encoder:**
```cpp
// File: main/led_strip_encoder.c - 32MHz timing
rmt_bytes_encoder_config_t bytes_cfg = {
    .bit0 = {
        .duration0 = 10,    // T0H: 312.5ns (10 × 31.25ns)
        .level0 = 1,        // High level
        .duration1 = 29,    // T0L: 906.25ns (29 × 31.25ns)  
        .level1 = 0         // Low level
    },
    .bit1 = {
        .duration0 = 29,    // T1H: 906.25ns (29 × 31.25ns)
        .level0 = 1,        // High level
        .duration1 = 10,    // T1L: 312.5ns (10 × 31.25ns)
        .level1 = 0         // Low level
    },
    .flags.msb_first = false  // LSB first for WS2812
};
```

**Synchronized Output:**
```cpp
void transmit_led_frame(led_controller_t *ctrl, uint8_t *ch2_data, size_t ch2_len,
                                                uint8_t *ch3_data, size_t ch3_len) {
    rmt_transmit_config_t tx_config = {
        .loop_count = 0,
        .flags.eot_level = 0,
        .flags.queue_nonblocking = false
    };
    
    // Reset synchronization manager
    ESP_ERROR_CHECK(rmt_sync_reset(ctrl->sync_manager));
    
    // Queue both channels simultaneously
    ESP_ERROR_CHECK(rmt_transmit(ctrl->rmt_channels[0], ctrl->led_encoders[0], 
                                ch2_data, ch2_len, &tx_config));
    ESP_ERROR_CHECK(rmt_transmit(ctrl->rmt_channels[1], ctrl->led_encoders[1], 
                                ch3_data, ch3_len, &tx_config));
    
    // Wait for completion of both channels
    ESP_ERROR_CHECK(rmt_tx_wait_all_done(ctrl->rmt_channels[0], portMAX_DELAY));
    ESP_ERROR_CHECK(rmt_tx_wait_all_done(ctrl->rmt_channels[1], portMAX_DELAY));
    
    // Send completion notification to C5
    printf("+LED_DONE\r\n");
}
```

## Custom AT Command Handlers

### Command Registration System

**Registration Pattern:**
```cpp
// File: main/EspAt_firmware.c
void register_all_commands() {
    static struct cat_command at_cmds[35];
    size_t at_cmd_count = 0;
    
    // System commands
    at_cmds[at_cmd_count++] = (struct cat_command){
        .name = "+RST",
        .run = at_cmd_rst,
    };
    
    at_cmds[at_cmd_count++] = (struct cat_command){
        .name = "+XSET", 
        .write = xset_handler,
        .read = xget_handler,
        .test = xtest_handler,
        .var = xvariables,
        .var_num = sizeof(xvariables)/sizeof(xvariables[0])
    };
    
    // BLE commands (10 commands)
    size_t ble_count;
    struct cat_command *ble_cmds = get_ble_commands(&ble_count);
    memcpy(&at_cmds[at_cmd_count], ble_cmds, ble_count * sizeof(struct cat_command));
    at_cmd_count += ble_count;
    
    // LED commands (3 commands)  
    size_t led_count;
    struct cat_command *led_cmds = get_led_commands(&led_count);
    memcpy(&at_cmds[at_cmd_count], led_cmds, led_count * sizeof(struct cat_command));
    at_cmd_count += led_count;
    
    // OTA command
    at_cmds[at_cmd_count++] = (struct cat_command){
        .name = "+OTAUPDATE", 
        .write = at_cmd_otaupdate
    };
    
    // Initialize CAT framework
    cat_init(&io, at_cmds, at_cmd_count, buffer, sizeof(buffer));
}
```

### LED AT Commands

**File**: `main/at_led_commands.c`

**AT+LED_PREP Implementation:**

**Source:** [at_led_commands.c:176-233](src/ESP32%20Wroom%20LED%20Driver%20firmware/main/at_led_commands.c#L176-L233)

**Command Format:** `AT+LED_PREP=<ch0_px>,<ch1_px>,<ch2_px>,<ch3_px>,<ch0_fmt>,<ch1_fmt>,<ch2_fmt>,<ch3_fmt>`

Where:
- `chX_px`: Pixel count for channel X (0-1200)
- `chX_fmt`: Format for channel X (3=RGB, 4=RGBW, 0=disabled)

```cpp
static cat_return_state at_cmd_led_prep_spi(const struct cat_command *cmd,
                                             const uint8_t *data,
                                             size_t size, size_t args_num) {
    // Parse 8 values: ch0_px, ch1_px, ch2_px, ch3_px, ch0_fmt, ch1_fmt, ch2_fmt, ch3_fmt
    uint16_t vals[8];
    size_t n;
    if (!parse_led_integers(data, size, vals, 8, &n) || n != 8) {
        send_at_response("ERROR");
        return CAT_RETURN_STATE_OK;
    }
    
    // Validate pixel counts (max 1200 per channel)
    for (int i = 0; i < 4; i++) {
        if (vals[i] > LED_MAX_PIXELS_PER_CHANNEL) {
            send_at_response("ERROR");
            return CAT_RETURN_STATE_ERROR;
        }
    }

    // Validate formats (3=RGB, 4=RGBW, 0=disabled)
    for (int i = 4; i < 8; i++) {
        uint16_t pixel_count = vals[i-4];
        uint16_t format = vals[i];
        if (pixel_count > 0 && format != 3 && format != 4) {
            send_at_response("ERROR");
            return CAT_RETURN_STATE_ERROR;
        }
    }

    // Prepare channel buffers and start reception
    uint16_t pixels[4] = {vals[0], vals[1], vals[2], vals[3]};
    uint8_t formats[4] = {(uint8_t)vals[4], (uint8_t)vals[5], (uint8_t)vals[6], (uint8_t)vals[7]};

    if (led_controller_prepare_buffers(g_spi_led_controller, pixels, formats) != LED_ERR_OK)
        return CAT_RETURN_STATE_ERROR;

    if (led_controller_start_receive(g_spi_led_controller,
                                     vals[0], vals[1], vals[2], vals[3]) != LED_ERR_OK)
        return CAT_RETURN_STATE_ERROR;

    write_to_at_console("OK\r\n");

    // Mark system as initialized after successful LED_PREP
    if (!h2_system_initialized) {
        h2_system_initialized = true;
        write_to_at_console("+H2_ALIVE:1\r\n");
    }
    return CAT_RETURN_STATE_OK;
}
```

**AT+LED_STATS Implementation:**
```cpp
static cat_return_state at_cmd_led_stats_spi(const struct cat_command *cmd,
                                              const uint8_t *data,
                                              size_t size, size_t args_num) {
    if (!g_spi_led_controller) {
        printf("+LED_STATS:UNINITIALIZED,0,0,0,0\r\n");
        return CAT_RETURN_STATE_OK;
    }
    
    const char *state_str = "UNKNOWN";
    switch (g_spi_led_controller->state) {
        case LED_STATE_IDLE: state_str = "IDLE"; break;
        case LED_STATE_PREPARED: state_str = "PREPARED"; break;
        case LED_STATE_RECEIVING: state_str = "RECEIVING"; break;
        case LED_STATE_PROCESSING: state_str = "PROCESSING"; break;
    }
    
    printf("+LED_STATS:SPI,%s,%lu,%lu,%lu\r\n",
           state_str,
           g_spi_led_controller->frames_processed,
           g_spi_led_controller->frame_errors,
           g_spi_led_controller->crc_errors);
           
    return CAT_RETURN_STATE_OK;
}
```

### OTA Update Handler

**File**: `main/ota.c`

**AT+OTAUPDATE Implementation:**
```cpp
static cat_return_state at_cmd_otaupdate(const struct cat_command *cmd,
                                          const uint8_t *data,
                                          size_t size, size_t args_num) {
    ESP_LOGI(TAG, "Starting OTA update process");
    
    // Create OTA task and return HOLD state
    xTaskCreate(ota_update_task, "ota_update", 8*1024, NULL, 4, NULL);
    
    return CAT_RETURN_STATE_HOLD;  // Suspend AT processing
}

void ota_update_task(void *arg) {
    esp_ota_handle_t ota_handle = 0;
    const esp_partition_t *update_partition = NULL;
    
    // Find update partition
    update_partition = esp_ota_get_next_update_partition(NULL);
    if (update_partition == NULL) {
        sendOtaError(OTA_ERR_NO_PARTITION);
        goto error_ret;
    }
    
    // Wait for sync pattern (6 bytes: C0 FF FE AA 55 90)
    uint8_t sync_pattern[6] = {0xC0, 0xFF, 0xFE, 0xAA, 0x55, 0x90};
    if (!wait_for_sync_pattern(sync_pattern, sizeof(sync_pattern))) {
        sendOtaError(OTA_ERR_SYNC_TIMEOUT);
        goto error_ret;
    }
    
    // Begin OTA process
    ESP_ERROR_CHECK(esp_ota_begin(update_partition, OTA_SIZE_UNKNOWN, &ota_handle));
    
    // Stream firmware data
    uint8_t data_buffer[1024];
    size_t data_read = 0;
    while ((data_read = read_ota_data(data_buffer, sizeof(data_buffer))) > 0) {
        ESP_ERROR_CHECK(esp_ota_write(ota_handle, data_buffer, data_read));
    }
    
    // Finalize OTA
    ESP_ERROR_CHECK(esp_ota_end(ota_handle));
    ESP_ERROR_CHECK(esp_ota_set_boot_partition(update_partition));
    
    printf("OK\r\n");
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
    
error_ret:
    if (ota_handle) esp_ota_end(ota_handle);
    printf("ERROR\r\n");
    vTaskDelete(NULL);
}
```

## Build and Flash Procedures

### ESP-IDF Project Configuration

**File**: `main/CMakeLists.txt`
```cmake
idf_component_register(
    SRCS 
        "EspAt_firmware.c"
        "cat.c"
        "ble_at_handler.c"
        "gap.c"
        "gatt_svc.c"
        "at_led_commands.c"
        "spi_led_controller.c"
        "led_strip_encoder.c"
        "ota.c"
    INCLUDE_DIRS "."
    REQUIRES 
        nvs_flash
        esp_driver_uart
        esp_driver_spi
        esp_driver_rmt
        bt
        app_update
)
```

**Required sdkconfig Options:**
```
CONFIG_BT_ENABLED=y
CONFIG_BT_NIMBLE_ENABLED=y
CONFIG_BT_NIMBLE_ROLE_PERIPHERAL=y
CONFIG_BT_NIMBLE_ROLE_CENTRAL=n
CONFIG_BT_NIMBLE_MAX_CONNECTIONS=1
CONFIG_BT_NIMBLE_MAX_CCCDS=8

CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=4096
CONFIG_FREERTOS_HZ=1000
CONFIG_ESP_DEFAULT_CPU_FREQ_96=y

CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
```

**Partition Table** (`partitions.csv`):
```
# Name,     Type, SubType, Offset,  Size, Flags
nvs,        data, nvs,     0x9000,  0x6000,
phy_init,   data, phy,     0xf000,  0x1000,
factory,    app,  factory, 0x10000, 0x180000,
ota_0,      app,  ota_0,   0x190000,0x180000,
ota_1,      app,  ota_1,   0x310000,0x180000,
ota_data,   data, ota,     0x490000,0x2000,
```

### Build Commands

```bash
# Configure for ESP32 (WROOM)
idf.py set-target esp32

# Configure project
idf.py menuconfig

# Build firmware
idf.py build

# Flash and monitor
idf.py flash monitor

# Flash specific address (for OTA testing)
esptool.py --port /dev/ttyUSB0 write_flash 0x190000 build/EspAt_firmware.bin
```

### Performance Characteristics

**Memory Usage:**
- **RAM**: ~70KB available (after BLE stack and buffers)
- **Flash**: ~400KB firmware size
- **Stack**: 8KB (CAT) + 4KB×2 (LED) + 4KB (BLE) = 20KB total

**Real-time Performance:**
- **SPI Reception**: 30 MHz, DMA-based, &lt;1% CPU
- **Frame Processing**: ~5µs CRC validation
- **RMT Output**: Synchronized dual-channel with &lt;5µs latency
- **BLE Latency**: Standard BLE characteristics (&lt;50ms)

This ESP32 WROOM implementation provides a robust, real-time capable platform for distributed LED control with comprehensive BLE connectivity and field-upgradeable firmware through the dual-MCU AT command interface.

## See Also

- **[ESP32-C5 Implementation Guide](esp32-c5-implementation.mdx)** - Complete documentation of the C5 main controller, including:
  - [LightPipe State Management](esp32-c5-implementation.mdx#lightpipe-state-management) - How the C5 monitors WROOM health via heartbeats
  - [Frame Data Protocol](esp32-c5-implementation.mdx#frame-data-protocol) - Binary frame format transmitted from C5 to WROOM
  - [GPIO Handshake Protocol](esp32-c5-implementation.mdx#gpio-handshake-protocol) - C5 perspective of the frame synchronization

- **[AT Protocol Documentation](at-protocol.mdx)** - Complete AT command reference and protocol specification

- **[Frame Data Protocol](frame-data-protocol.mdx)** - Deep dive into the binary frame format and CRC validation